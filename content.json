{"meta":{"title":"ZSP's Blog","subtitle":"airbash","description":"专注 JAVA 开发的技术博客","author":"ZSP","url":"https://airbash.cn","root":"/"},"pages":[{"title":"","date":"2019-11-06T03:36:22.461Z","updated":"2019-11-06T03:36:22.461Z","comments":true,"path":"about/index.html","permalink":"https://airbash.cn/about/index.html","excerpt":"","text":"关于我从事 JAVA 开发，主要开发语言 JAVA，熟悉使用 SpringBoot、SpringMVC 等主流框架；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：北京 关于学习正在往终身学习者前进…近期学习方向：Python (人工智能) 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Home: airbash.com Blog: airbash.com Email: 294379349@qq.com GitHub: yanxuedesaonian WeiBo: ZSP赵帅鹏"}],"posts":[{"title":"Markdown中设置图片大小的几种方法","slug":"Markdown/ImgSize","date":"2019-11-06T19:44:17.000Z","updated":"2019-11-06T20:19:37.963Z","comments":true,"path":"2019/11/07/Markdown/ImgSize/","link":"","permalink":"https://airbash.cn/2019/11/07/Markdown/ImgSize/","excerpt":"","text":"Markdown 让你专注于内容而不是格式，但是有时候你确实想要控制一下显示效果，比如说图片。在 markdown 中，图片是通过这样的方式插入的： 1![test image size](/img/post-bg-2015.jpg) 默认是最大化，如果我们想要控制图片的显示大小，怎么做呢？最简单直观的做法就是使用原始的 HTML 标签： 1&lt;img src=&quot;http://arganzheng.life/img/post-bg-2015.jpg&quot; height=&quot;100px&quot; width=&quot;400px&quot; &gt; 但是这样子就不是纯粹的 markdown 文本了，是 markdown 跟 html 的混合体，当然图片这个 html 标签还算是简洁。 另一种方式就是通过外部的 CSS 控制，对 post 中的所有 img 做统一处理： 12345img[alt=img_alt_you_want_to_control] &#123; width: 70%; border: none; background: none;&#125; 然后对于你想要控制显示效果的 img 使用这个 alt: 1![img_alt_you_want_to_control](/img/post-bg-2015.jpg) 不过这种方式对所有的 img 显示效果统一处理了，而且对 alt 有要求（当然你可以用其他的方式定位到文章中的 img），不是很灵活。 谷歌了一下，发现其实有些 markdown 实现是支持指定图片属性的，如 kramdown : Here is an inline ![smiley](smiley.png){:height=&quot;36px&quot;width=&quot;36px&quot;} . 会渲染成： 1&lt;img src=&quot;http://arganzheng.life/smiley.jpg&quot; alt=&quot;smiley&quot; height=&quot;36px&quot; width=&quot;36px&quot;&gt; 所以我们可以这么指定： 123![test image size](/img/post-bg-2015.jpg)&#123;:class=&quot;img-responsive&quot;&#125;![test image size](/img/post-bg-2015.jpg)&#123;:height=&quot;50%&quot; width=&quot;50%&quot;&#125;![test image size](/img/post-bg-2015.jpg)&#123;:height=&quot;100px&quot; width=&quot;400px&quot;&#125; 渲染结果如下： 123&lt;img src=&quot;http://arganzheng.life/img/post-bg-2015.jpg&quot; alt=&quot;test image size&quot; class=&quot;img-responsive&quot;&gt;&lt;img src=&quot;http://arganzheng.life/img/post-bg-2015.jpg&quot; alt=&quot;test image size&quot; height=&quot;50%&quot; width=&quot;50%&quot;&gt;&lt;img src=&quot;http://arganzheng.life/img/post-bg-2015.jpg&quot; alt=&quot;test image size&quot; height=&quot;100px&quot; width=&quot;400px&quot;&gt; 因为我们没有在 CSS 上定义 img-responsive class，所以这里第一个没有效果。 你需要在你的 jekyll 配置文件 (_config) 中告诉它使用 kramdown 渲染： 1234567# Markdown settings# replace redcarpet to kramdown,# although redcarpet can auto highlight code, the lack of header-id make the catalog impossible, so I switch to kramdown# document: http://jekyllrb.com/docs/configuration/#kramdownmarkdown: kramdownkramdown: input: GFM # use Github Flavored Markdown !important TIPS 1、上面第二种方式，也可以使用隐藏的 html 标签做控制： 12![test image size](/img/post-bg-2015.jpg)&lt;!-- .element height=&quot;50%&quot; width=&quot;50%&quot; --&gt;![test image size](/img/post-bg-2015.jpg)&lt;!-- .element style=&quot;border: 0; background: None; box-shadow: None&quot; --&gt; 不过个人感觉还是 kramdown 的语法简单明了。 2、细心的读者可能会发现图片的显示效果不是 400x100，这是因为我在 CSS 中对 post 中的所有 img 做了统一的处理： 123456.post-container img &#123; display: block; max-width: 100%; height: auto; margin: 1.5em auto 1.6em;&#125; 所以上面 height 的指定其实是没有效果的，我只需要控制好 width 就可以了，这样可以避免变形。 Enjoy writing! –EOF– 参考文章 Inserting Images in Markdown Jekyll Posts","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://airbash.cn/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://airbash.cn/tags/Markdown/"}]},{"title":"Sublime实时预览markdown","slug":"Sublime/Markdown","date":"2019-11-06T19:27:17.000Z","updated":"2019-11-06T19:45:04.428Z","comments":true,"path":"2019/11/07/Sublime/Markdown/","link":"","permalink":"https://airbash.cn/2019/11/07/Sublime/Markdown/","excerpt":"","text":"本文由 简悦 SimpRead 转码， 原文地址 https://blog.csdn.net/qq_20011607/article/details/81370236 如前文《Sublime Text3 的插件管理工具 (Package Control) 的安装及使用方法》所说，Sublime 有强大的插件扩展功能，本文将详细介绍在用 Sublime 写 Markdown 文档时如何预览，甚至是实时刷新预览。 温习：插件安装方式，后面会反复用到 组合键Ctrl+Shift+P 调出命令面板 输入Package Control: Install Package，回车 在搜索框中输入要安装的包名（一个一个，不能同时安多个） 静待几秒即可安装成功 插件介绍介绍几个 Markdown 类的常用插件： 插件 功能 MarkdownEditing 一个提高 Sublime 中 Markdown 编辑特性的插件 MarkdownPreview Markdown 转 HTML，提供在浏览器中的预览功能 MarkdownLivePreview 提供在编辑框中实时预览的功能 LiveReload 一个提供 md/html 等文档的实时刷新预览的的插件 接下来会一次介绍这几个插件。 MarkdownEditing 顾名思义，Markdown 编辑器，是 Markdown 写作者必备的插件，不仅可以高亮显示 Markdown 语法还支持很多编程语言的语法高亮显示。特别注意：MarkdownEditing 只针对 md\\mdown\\mmd\\txt 格式文件才启用。 特性MarkdownEditing 从视觉和便捷性上针对 Markdown 文档的编辑进行了一系列的优化。如： 颜色方案仿 Byword 及 iA writer 自动匹配星号（*）、下划线（_）及反引号（`） 选中文本按下以上符号能自动在所选文本前后添加配对的符号 方便粗体、斜体和代码框的输入 效果图： MarkdownLivePreview 功能实时预览 Markdown 文件，左侧为 md 文件，右侧为预览结果。可配合 MarkdownEditing 一起使用。 使用MarkdownLivePreview 默认关闭实时预览，既然安装这个插件了，那肯定是要用的。打开方式为在Preferences -&gt; Package Settings -&gt; MarkdownLivePreview -&gt; Settings 的设置的右侧加一条 &quot;markdown_live_preview_on_open&quot;: true,，重启 sublime 即可。 为什么不能直接将左侧对应的 false 改为 true，这是因为左侧为默认配置，是不能改的（只读），右侧的编辑区才是用户自定义区。 效果图以下为配合 MarkdownEditing 的效果：实际预览效果并不理想, 很丑, 而且不能横向滚动, 也就是说如果一行显示不过来那你就看不到 了。偶然也会有些卡, 所以其实推荐的是下面这个插件。 MarkdownPreview 功能 支持在浏览器中预览 markdown 文件 将 md 文件导出为 html 代码 将 md 文件用浏览器预览——1. 常规方法 组合键 Ctrl+Shift+P 调出命令面板 输入mdp找到并选中Markdown Preview： Preview in Browser 出现两个选项：github和markdown。任选其一即可，github 是利用 GitHub 的在线 API 来解析. md 文件，支持在线资源的预览，如在线图片它的解析速度取决于你的联网速度。该方式据说一天只能打开 60 次。markdown 就是传统的本地打开，不支持在线资源的预览。 默认浏览器中显示预览结果 将 md 文件用浏览器预览——2. 用快捷键打开Sublime Text 支持自定义快捷键，Markdown Preview 默认没有快捷键，我们可以自己为Markdown Preview： Preview in Browser设置快捷键。方法是在Preferences -&gt; Key Bindings打开的文件的右侧栏的中括号中添加一行代码： 1&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125; 这里： &quot;alt+m&quot; 可设置为自己喜欢的按键。&quot;parser&quot;: &quot;markdown&quot;也可设置为&quot;parser&quot;:&quot;github&quot;，改为使用 Github 在线 API 解析 markdown。 以上两种方式都有个问题：每次预览都要打开一个新的网页，而且需要手动操作。有没有一个方法，可以打开一个网页后，之后再也不用管，让它实时刷新预览呢？ 有，还很简单，答案就是MarkdownPreview+LiveReload！LiveReload 是一个可实时刷新的插件，不仅可用于 Markdown，也可用于 HTML 等。 （最强）实时自动刷新预览：MarkdownPreview + LiveReload 先安装并配置 Markdown Preview如前 Markdown Preview 安装成功后，设置前文所述的快捷键（如需），打开其配置文件 Preferences -&gt; Package Settings -&gt; Markdown Preview -&gt; Settings，检查左侧 enable_autoreload 条目是否为 true，若是，跳过。若不是，右侧栏加一条下面这个后重启 Sublime: 123&#123; &quot;enable_autoreload&quot;: true&#125; 安装并配置 LiveReloadCtrl+Shift+p, 输入 Install Package，输入LiveReload, 回车安装安装成功后, 再次Ctrl+shift+p, 输入LiveReload: Enable/disable plug-ins, 回车, 选择 Simple Reload with delay (400ms)或者Simple Reload，两者的区别仅仅在于后者没有延迟。 开始使用如前面提到的手动或者快捷键打开预览网页，之后便再也不用管它，只要你的 sublime 保存一次，网页那边就会自动刷新预览，美滋滋。 但是呢，有个遗留的问题：网页预览不能跟随你的 sublime 编辑位置，还需要你滑动页面。在这一点上，CSDN-Markdown 可以说很优秀了，本文就是在该编辑器下完成的。 作者：张渊猛","categories":[{"name":"IDE","slug":"IDE","permalink":"https://airbash.cn/categories/IDE/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://airbash.cn/tags/Markdown/"},{"name":"Sublime","slug":"Sublime","permalink":"https://airbash.cn/tags/Sublime/"},{"name":"IDE","slug":"IDE","permalink":"https://airbash.cn/tags/IDE/"}]},{"title":"生成sitemap站点目录","slug":"Hexo/GenerateSiteMap","date":"2019-11-06T06:41:07.000Z","updated":"2019-11-06T18:51:20.508Z","comments":true,"path":"2019/11/06/Hexo/GenerateSiteMap/","link":"","permalink":"https://airbash.cn/2019/11/06/Hexo/GenerateSiteMap/","excerpt":"","text":"百度+谷歌都无法搜索到我的博客 不能忍 1.先确认博客是否被收录在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有。 1site:site.cn 2.创建站点地图文件站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客目录的_config.yml中添加如下代码 1234567Plugins: - hexo-generator-baidu-sitemap - hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了 3.让百度收录我们的博客 验证网站 为什么要验证网站 站长平台推荐站长添加主站（您网站的链接也许会使用www 和非 www 两种网址，建议添加用户能够真实访问到的网址），添加并验证后，可证明您是该域名的拥有者，可以快捷批量添加子站点，查看所有子站数据，无需再一一验证您的子站点。 如何验证网站 首先如果您的网站已使用了百度统计，您可以使用统计账号登录平台，或者绑定站长平台与百度统计账号，站长平台支持您批量导入百度统计中的站点，您不需要再对网站进行验证。 百度站长平台为未使用百度统计的站点提供三种验证方式：文件验证、html标签验证、CNAME验证。 验证完成后，将会认为您是网站的拥有者。为使您的网站一直保持验证通过的状态，请保留验证的文件、html标签或CNAME记录，会去定期检查验证记录。 访问流程 访问百度站长平台 输入你的网址 3. 这里推荐使用CNAME验证证,因为这样不影响我们HEXO的操作. 链接提交上面步骤成功后，进入站点管理，选择网页抓取——链接提交 这里推荐自动推送和sitemap从效率上来说： 1主动推送&gt;自动推送&gt;sitemap 自动推送自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度复制代码到下面目录文件里就好添加到下面就行。 1\\themes\\xxxx\\layout\\_partial\\after_footer.ejs sitemap提交直接提交就行 如何选择链接提交方式? 1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。4、手动提交：一次性提交链接给百度，可以使用此种方式。 4.谷歌收录我们的博客谷歌操作比较简单，就是向Google站长工具提交sitemap登录Google账号，添加了站点验证通过后，选择站点，之后在抓取——站点地图——添加/测试站点地图，如下图： 谷歌我提交立马就能搜索到我的博客了，效率很高。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://airbash.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://airbash.cn/tags/Hexo/"}]},{"title":"Log4J","slug":"Apache/Log4J","date":"2019-11-02T13:10:15.000Z","updated":"2019-11-06T13:17:36.602Z","comments":true,"path":"2019/11/02/Apache/Log4J/","link":"","permalink":"https://airbash.cn/2019/11/02/Apache/Log4J/","excerpt":"","text":"1.基础知识 作用: 记录项目产生的日志:调试日志/运行日志/异常日志 实现方式: JDK的logger log4j和log4j2 日志级别 日志 级别 作用 fatal 1(最高) 致命 error 2 warn 3 info 4 debug 5 调试 trace 6 堆栈 2. 基础配置1.添加依赖 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 调价报错依赖 SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”.SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt; 2.配置文件 log4j.properties 123456789101112131415161718192021222324252627log4j.rootLogger=DEBUG,Console,File,DailyRollingFile,RollingFile #Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n #Filelog4j.appender.File = org.apache.log4j.FileAppenderlog4j.appender.File.File = D://log1.loglog4j.appender.File.layout = org.apache.log4j.PatternLayoutlog4j.appender.File.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%nlog4j.appender.File.Append = false#DailyRollingFilelog4j.appender.DailyRollingFile = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.DailyRollingFile.File = D://log2.loglog4j.appender.DailyRollingFile.layout = org.apache.log4j.PatternLayoutlog4j.appender.DailyRollingFile.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n#RollingFilelog4j.appender.RollingFile = org.apache.log4j.RollingFileAppenderlog4j.appender.RollingFile.File = D://log3.loglog4j.appender.RollingFile.MaxFileSize=1KBlog4j.appender.RollingFile.MaxBackupIndex=3log4j.appender.RollingFile.layout = org.apache.log4j.PatternLayoutlog4j.appender.RollingFile.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n 详解 输出等级 123#将DEBUG及以上日志使用输出类型输出#OFF(0)&lt;FIFAL&lt;ERROR&lt;WARN&lt;INFO&lt;DEBUG&lt;ALL(全部)log4j.rootLogger=DEBUG,输出类型1[,输出类型2] 输出格式: log4j.appender.输出名称.layout=org.apache.log4j.PatternLayout推荐配置 格式名称 作用 注意事项 org.apache.log4j.HTMLLayout 以HTML表格形式布局 org.apache.log4j.PatternLayout 可以灵活地指定布局模式 org.apache.log4j.SimpleLayout 包含日志信息的级别和信息字符串 org.apache.log4j.TTCCLayout 包含日志产生的时间、线程、类别等等信息 自定义配置 log4j.appender.输出名称.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n推荐配置 配置类型 配置名称 注意事项 %m 输出代码中指定的消息； %M 输出打印该条日志的方法名； %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL； %r 输出自应用启动到输出该log信息耗费的毫秒数； %c 输出所属的类目，通常就是所在类的全名； %t 输出产生该日志事件的线程名； %n 输出一个回车换行符，Windows平台为”rn”，Unix平台为”n”； %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy-MM-dd HH:mm:ss,SSS}，输出类似：2002-10-18 22:10:28,921； %l 输出日志事件的发生位置，及在代码中的行数 输出类型 log4j.appender.输出类型=org.apache.log4j.输出类型Appender 输出类型 作用 注意事项 Console 控制台 File 只产生一个日志文件 DailyRollingFile 每天产生一个日志文件 RollingFile 文件大小超过指定大小时产生新文件 WriterAppender 将日志信息以流格式发送到任意指定的地方 输出名称 输出类型 输出名称 File 默认续写 DailyRollingFile 最后一天的名称与输出名称相同,之前的为 输出名称+日期 RollingFile 当超过配置的制定大小时创建新文件,文件名为 输出名称n 1log4j.appender.输出类型.File = D://log.log 额外配置 12345678#File 当配置false时不续写,直接覆盖log4j.appender.File.append = false#DailyRollingFile# RollingFile:当文件大小超过1KB时新建新文件,当文件数超过3个时覆盖之前的文件log4j.appender.RollingFile.MaxFileSize=1KBlog4j.appender.RollingFile.MaxBackupIndex=3 3.java配置 新建logger事例 1Logger logger = Logger.getLogger(当前.class); 格式化logger 1logger.日志级别名(\"显示信息\"); 格式化错误日志 1logger.日志级别名(\"显示信息\",new 错误); 3.框架配置1.Spring MVC web.xml 12345678910111213141516171819&lt;!-- 加载log4j的配置文件log4j.properties --&gt;&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 设定刷新日志配置文件的时间间隔，这里设置为10s --&gt;&lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;10000&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 加载Spring框架中的log4j监听器Log4jConfigListener --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 为避免项目间冲突，定义唯一的 webAppRootKey --&gt;&lt;context-param&gt; &lt;param-name&gt;webAppRootKey&lt;/param-name&gt; &lt;param-value&gt;scheduleProject&lt;/param-value&gt;&lt;/context-param&gt; 2.Spring Boot直接使用即可","categories":[{"name":"Apache","slug":"Apache","permalink":"https://airbash.cn/categories/Apache/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://airbash.cn/tags/Apache/"},{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"log4j","slug":"log4j","permalink":"https://airbash.cn/tags/log4j/"}]},{"title":"Lucene","slug":"Apache/Lucene","date":"2019-11-02T13:02:40.000Z","updated":"2019-11-06T13:15:27.703Z","comments":true,"path":"2019/11/02/Apache/Lucene/","link":"","permalink":"https://airbash.cn/2019/11/02/Apache/Lucene/","excerpt":"","text":"1.基础知识1.相关依赖1.官网依赖包官方下载 2.maven多个maven包版本号要相同 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;包名&lt;/artifactId&gt; &lt;version&gt;版本号&lt;/version&gt;&lt;/dependency&gt; 包名 作用 lucene-core 核心包 lucene-analyzers-common 分词功能 lucene-queryparser 分词查询 2.Luke可视化工具在Lucene8.0.0以后的版本中官方包中自带Luke,官方原官方项目托管已停止更新,8.0.0以前的可查看现官方项目; 2.Lucene核心类 创建 作用 查询 作用 IndexWriter 写入索引流 IndexReader 读取索引流 Analyzer 分析器 Query 查询方式 Document 文档 indexSearcher 搜索 Field 域 Term 类似域 其他类 作用 Directory TokenStream TermAttribute 1.创建索引1.Analyer 分词器 详解 StandardAnalyzer 默认分词器,中文词会被拆分成单个字 IKAnalyzer 中文分词器,官方项目已停止更新,可用别人开发的项目(maven) 2.Document文档对象包含域 3.Field Field类型 数据类型 Analyzed 是否分析 Indexed 是否索引 Stored 是否存储 说明 StringField(FieldName, FieldValue,Filed.Store.YES/NO)) 字符串 N Y Y或N 这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等) LongPoint/IntPoint(String name, long… point) Long型 Y Y N 可以使用LongPoint、IntPoint等类型存储数值类型的数据。让数值类型可以进行索引。但是不能存储数据，如果想存储数据还需要与StoredField一起使用。 StoredField(FieldName, FieldValue) 重载方法，支持多种类型 N N Y 这个Field用来构建不同类型Field 不分析，不索引，但要Field存储在文档中,可以使用LongPoint以后在使用这个进行存储 TextField(FieldName, FieldValue, Filed.Store.YES/NO) 或 TextField(FieldName, reader) 字符串 或 流 Y Y Y或N 如果是一个Reader, Lucene猜测内容比较多,会采用Unstored的策略. 文件的大小/内容/名称/地址都可以加入域中 2.查询索引1.Query 搜索方式 作用 TermQuery 根据域名和关键词搜索 RanageQuery 根据范围查询 2.TopDocs 方法/属性 作用 返回值 totalHits 符合搜索条件的文档数量 TotalHits对象 (输出为:n hits) socreDocs 符合搜索条件的结果 scoreDoc数组 getMaxScore() 返回最大评分 TopDocs() 排序(多个重载方法) 1.ScoreDoc 方法/属性 作用 score 文档的查询分数 doc 文档编号 shardIndex 未知/不常用 2.TotalHits 方法/属性 作用 value 输出数值n(Int) relation 命中范围(未知/不常用) 3.执行流程1.创建索引 指定索引库保存位置 123Path path = new File(\"地址\").toPath();Path path = Paths.get(\"地址);Directory directory = FSDirectory.open(path);//需要抛出IO异常 新建分词器 1Analyzer analyzer = new 分词器名(); 新建写入索引配置对象 1IndexWriterConfig config= new IndexWriterConfig(analyzer);//不写参数代表默认配置 新建写入索引对象 1IndexWriter indexWriter = new IndexWriter(directory,config); 创建文档对象 1Document document = new Document();//建议1个文档对应所有类型的域各一个 创建域 文件的大小/内容/名称/地址都可以加入域中 1Field field = new 域类型(\"域名\",\"内容\",Filed.Store.YES);//yes代表存储,no代表不存储. 添加一条记录 1document.add(field); 将记录添加到索引事例中 1indexWriter.addDocument(document); 关闭索引事例 1indexWriter.close(); 2.演示分词效果 新建分词对象 1Analyzer anlyzer= new 分词对象(); 创建标记流,测试域名 1TokenStream tokenStream = anlyzer.tokenStream(\"域名\",\"事例文字或者流\");//域名可不写 添加功能 名称 作用 注意事项 CharTermAttribute 表示token本身的内容 OffsetAttribute 表示token的首字母和尾字母在原文本中的位置 首字母:startOffset()/尾字母:startOffset() TypeAttribute 表示token的词汇类型信息，默认值为word，其它值有&lt;ALPHANUM&gt; &lt;APOSTROPHE&gt; &lt;ACRONYM&gt;&lt;COMPANY&gt; &lt;EMAIL&gt; &lt;HOST&gt; &lt;NUM&gt; &lt;CJ&gt; FlagsAttribute 与TypeAttribute类似，假设你需要给token添加额外的信息，而且希望该信息可以通过分析链，那么就可以通过flags去传递 PositionIncrementAttribute 表示当前token相对于前一个token的相对位置，也就是相隔的词语数量,如果两者之间没有停用词，那么该值默认为1 例如“text for attribute”，text和attribute之间的getPositionIncrement为2 PayloadAttribute 在每个索引位置都存储了payload（关键信息），当使用基于Payload的查询时，该信息在评分中非常有用 1功能类 x = tokenStream.addAttribute(功能名.class); 重置标记流 1tokenStream.rest();//会抛出IOException 遍历tokenStream 123while(tokenStream.incrementToken()&#123;//返回flase表示结束 sout(CharTermAttribute.toString());&#125; 关闭标记流 12tokenStream.end();//待学tokenStream.close(); 3.查询索引1.Query子类 指定索引库位置 1Directory directory = FSDirectory.open(path); 创建读取索引事例 1IndexReader indexReader = DirectoryReader.open(directory); 创建搜索对象 1IndexSearcher indexSearcher = new IndexSearcher(indexReader); 指定搜索方式 123Query query = 搜索方式(term);Query query = new TermQuery(new Term(\"搜索域\",\"关键词\"));//1.TermQueryLongPoint.RangeQuery(\"搜索域\",startL,endL);//2.RangeQuery 设置query和显示个数并返回结果 1TopDocs topDocs = indexSearcher.search(query,10); 显示搜索结果的信息集数组 1ScoreDoc[] scoreDocs = topDocs.scoreDocs; 显示结果 12345for(ScoreDoc scoreDoc:scoreDocs)&#123; int docId = scoreDoc.doc; //信息集的id Document document = indexSearcher.doc(docId); //通过id获取文档 System.out.println(document.get(\"域名\")); //根据域名查询内容&#125; 2.QueryParser修改第4部分 123456//1.创建分词器Analyzer analyzer = new IKAnalyzer();//2.创建QueryParaser对象QueryParser queryParser = new QueryParser(&quot;name&quot;, analyzer);//3.创建Queryquery = queryParser.parse(&quot;lucene是一个java开发的全文检索工具包&quot;); 4.管理索引库1.添加索引跟添加索引一样的操作 2.删除索引指定索引库–&gt;1/2—&gt;结束 1.删除所有索引1indexWriter.deleteAll(); 2.根据查询删除索引1indexWriter,deleteDocuments(new Term(\"域名\",\"关键词\")); 3.修改索引跟添加索引库一样只不过document.add()修改为下列代码 修改后的文档 1document.add(new TextField(\"要修改的域名\",\"修改后的内容\",存储类型)) 根据搜索关键词替换document 1indexWriter.updateDocument(new Term(\"域名\",\"关键词\"),document);","categories":[{"name":"Apache","slug":"Apache","permalink":"https://airbash.cn/categories/Apache/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://airbash.cn/tags/Apache/"},{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"Lucene","slug":"Lucene","permalink":"https://airbash.cn/tags/Lucene/"}]},{"title":"JQuery","slug":"前端/JQuery","date":"2019-11-02T12:52:17.000Z","updated":"2019-11-06T03:36:22.450Z","comments":true,"path":"2019/11/02/前端/JQuery/","link":"","permalink":"https://airbash.cn/2019/11/02/%E5%89%8D%E7%AB%AF/JQuery/","excerpt":"","text":"一.基础知识1.安装使用 离线使用 从网上下载jQuery的JS文件,放到项目目录 使用时导入到需要使用的文件中(导入行内不能写代码) 1&lt;script type=\"text/javascript\" src=\"../js/jquery-1.4.2.js\"&gt;&lt;/script&gt; 在线使用 1&lt;script type=\"text/javascript\" src=\"地址\"&gt;&lt;/script&gt; 2.注意事项 优势 相对于js能更好的选择元素,修改css 当一个网站下载完以后,另一个网站可以复用 详细介绍: jQuery是一个用js写的js框架 选择器时jQuery的基础 创建新元素时命名为$(),或者jQuery() 3.对象转换jQ对象和JS对象之间的方法不同互相使用 js转换为jQuery: 1js转jq var jq = $(js); jQuery转换为js: 1jq转js var js = jq[0]; 4.区别/方法 jq代码 js代码 val() value eq(n) 遍历 each() 循环遍历 load onload 5.遍历数组 jQuery方法调用 1234var a = [1, 2, 3, 4];$.each(a, function(key, val) &#123;//以jQuery对象的方法调用，兼容性好; console.log(a[key] + '下标为' + key + '值为' + val);&#125;); 对象转换调用 1234//也可以用$(a)将a转化为jquery对象，然后以下列方式的形式调用$(a).each(function(key,val)&#123; console.log(a[key] + '下标为' + key + '值为' + val);&#125;); 遍历对象时 $(“img”).eq(0)=$(this)=$(val) 二.选择器(获取元素)1.基本选择器 代码 选择器 $(“*”) 任意元素选择器 $(“标签名”) 标签名选择器 $(“#id名”) Id选择器 $(“.class名”) class选择器 $(“标签名,#id,.class”) 分组选择器 $(“标签名.class名”) 元素选择器(标签名为XXX且class名为XXX) 2.层级选择器 代码 选择器 $(“div span”) 匹配所有div下的span元素 包含所有后代 $(“div&gt;span”) 匹配所有div下的span子元素 $(“div+span”) 匹配所有div后面的第一个弟弟元素 $(“div~span”) 匹配所有div后面所有的span弟弟们元素 2.2层级方法不包括自身/当选择器全部选择,然后查找兄弟元素,第一个不被选择 代码 方法 $(“#abc”).siblings(“div”) 匹配id为abc元素的所有兄弟元素 $(“#abc”).next(“div”) 匹配id为abc元素的弟弟元素 $(“#abc”).nexAll() 匹配id为abc元素的弟弟元素们 $(“#abc”).prev(“div”) 匹配id为abc元素的哥哥元素 $(“#abc”).prevAll() 匹配id为abc元素的哥哥元素们 3.过滤选择器 代码 选择器 $(“div:first”) 匹配所有div元素中的第一个 存在单独方法 $(“div:last”) 匹配所有div元素中的最后一个 存在单独方法 $(“div:even”) 匹配所有div元素中的偶数个 从0开始 $(“div:odd”) 匹配所有div元素中的奇数个 从0开始 $(“div:eq(n)”) 匹配第n个div元素 存在单独方法 $(“div:lt(n)”) 匹配所有下标小于n的所有div元素 $(“div:gt(n)”) 匹配所有下标大于n的所有div元素 $(“div:not(.abc)”) 匹配所有div中class值不等于abc的 3.3过滤方法 代码 实例 $(“#abc”).filter(function(index,ele){index相关flag return true}) 过滤return为 true的所有div元素 $(“#abc”).map(function(index,ele){index相关flag return ele}) 过滤return为ele的div元素 $(“#abc”).find(“.class名”) 匹配class为”class名”的所有div元素 $(“#abc”).not(“.class名”) 匹配class不为”class名”的所有div元素 $(“#abc”).is(“.class名”) 检查class为”class名”的所有div元素 $(“#abc”).slice(a,b) 匹配[a,b)div元素,不写b时代表[a,+无限) $(“#abc”).has(p) 匹配所有包含p子元素的div 4.内容选择器 代码 选择器 $(“div:has(p)”) 匹配所有包含p子元素的div $(“div:empty”) 匹配所有空的div $(“div:parent”) 匹配所有非空的div $(“div:contains(‘abc’)”) 匹配所有包含abc文本的div 5.属性选择器 代码 选择器 $(“div[id]”) 匹配所有包含id属性的元素 $(“div[id=’d1’]”) 匹配所有id等于d1的元素 $(“div[id!=’d1’]”) 匹配所有id不等于d1的元素 6.可见选择器 代码 选择器 $(“div:hidden”) 匹配所有隐藏的div元素 $(“div:visible”) 匹配所有显示的div元素 6.2隐藏显示相关的方法 代码 选择器 $(“#abc”).hide(); 隐藏 $(“#abc”).show(); 显示 $(“#abc”).toggle(); 隐藏显示切换 7.子元素选择器 代码 选择器 $(“div:nth-child(n)”) 匹配所有是div并且是第n个子元素 //从1开始 $(“div:first-child”) 匹配所有是div并且是第一个子元素 $(“div:last-child”) 匹配所有是div并且是最后一个子元素 8.表单选择器 代码 选择器 $(“:input”) 匹配form表单中所有的控件 $(“:password”) 匹配所有密码框 $(“:radio”) 匹配所有单选框 $(“:checkbox”) 匹配所有多选框 $(“:checked”) 匹配所有选中的单选、多选、下拉选 $(“input:checked”) 匹配所有选中的单选和多选 $(“:selected”) 匹配所有选中的下拉选 三.添加元素 创建元素 不立即生效,需要下面三个方法的协助 1新元素 = $(\"&lt;div id='xxx'&gt;xxxxx&lt;/div&gt;\"); 添加元素 12父元素.append(新元素); //添加到最后面父元素.prepend(新元素); //添加到最前面 插入元素 12兄弟元素.before(新元素);//插入到元素的前面兄弟元素.after(新元素);//插入到元素的后面 删除元素 1被删除元素.remove(); 四.写入元素 注意事项: js上这里赋值也是”=”,jq变成类似java正常情况; ()内不写代表取值; 以下内容跟js一样都添加新元素时删除之前的配置 创建的html新元素只能添加一遍,第二次添加的话不生效 可以将创建的新元素1添加到新元素2,然后将新元素2添加到文件中 文本相关 12元素.text(\"xxx\"); //给元素添加文本内容var str = 元素.text(); //获取元素的文本内容 html相关 12元素.html(\"&lt;h1&gt;xxx&lt;/h1&gt;\"); //给元素添加html内容var html = 元素.html(); //获取元素的html内容 css样式相关 123元素.css(\"样式名称\",\"值\"); //给元素添加样式元素.css(&#123;\"css名称1\":\"值1\",\"css名称2\":\"值2\"&#125;); //给元素添加多种样式var x = 元素.css(\"样式名称\"); //获取元素某个样式的值 属性相关 注意事项: 不删除之前的配置 attr和prop区别 attr prop 可以获取和添加固定属性和自定义标签 只能获取和添加固定属性 获取未设置属性返回undefined 获取未设置属性返回null 可以动态获取checked的值(true或false) 固定属性:已经html标签 自定义属性:自己定义的标签 1.attr 添加属性 1元素.attr(\"属性名\",\"属性值\"); 获取属性 1var x = 元素.attr(\"属性名\"); 删除属性 1var.Removeattr(\"属性名\"); 2.prop 添加属性 1元素.prop(\"属性名\",\"属性值\"); 获取属性 1var x = 元素.prop(\"属性名\"); 删除属性 1var.Removeprop(\"属性名\"); 3.class 添加class 相比较与attr可以分别设置而不用遍历 不删除之前的配置 12345$(\"\").addClass(function(index ele)&#123; if(index相关flag)&#123; return \"数值\"; &#125;&#125;) 删除class 1$(\"\").removeClass(\"数值\"); 判断是否含有class 相比较与attr可以不写全class名 用于多class名 1$(\"\").hasClass(\"class名\"); 4.checked​ checked或者true 五.Cookie 存入cookie 1$.cookie(数据名, 数据值, &#123;expire: 有效期为多少天&#125;); 使用cookie 1$.cookie(数据名); 六.事件 事件 描述 js click() onclick()","categories":[{"name":"前端","slug":"前端","permalink":"https://airbash.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://airbash.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Jquery","slug":"Jquery","permalink":"https://airbash.cn/tags/Jquery/"}]},{"title":"SpringBoot","slug":"Spring/SpringBoot","date":"2019-11-02T12:45:20.000Z","updated":"2019-11-06T03:36:22.445Z","comments":true,"path":"2019/11/02/Spring/SpringBoot/","link":"","permalink":"https://airbash.cn/2019/11/02/Spring/SpringBoot/","excerpt":"","text":"1.基础配置它是一个默认添加了许多依赖，完成了许多(公共)默认的配置，集成了主流的Spring+SpringMVC的框架。 1. 创建项目 打开网址 http://start.spring.io; 填写参数,选择额外依赖,点击Generate Project按钮 下载项目压缩包 解压压缩包并剪切到eclipse项目目录中 eclipse中导入项目:Import&gt; Existing Maven Projects,并自动下载依赖; 2. maven配置 自动添加 1234567891011121314151617181920212223242526272829303132&lt;!--SpringBoot默认:配置MVC或Mybatis时会被替换--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--SpringBoot默认:junit下列框架默认都有--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--mysql/jdbc驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--SpringMVC:替换Spring-starter--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt;&lt;!--Mybatis:替换Spring-starter--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 3. 默认配置 推荐把静态资源(html/图片/css/js素材)放到resources/static文件夹中 java文件夹中默认创建了cn.tedu.groupiD名.项目名包,Spring专属包;并在该包创建项目名Application.java文件,该类时启动类 项目内置独立Tomcat,并且不用部署,使用时直接执行启动类就行,直接访问http://localhost:8080/ 默认配置了DispatcherServlet,处理路径是/*,后缀无(任意都行) 默认配置了StringHtppMessageConverter,字符集UTF-8 默认添加了jackson依赖,boot推荐服务器这样做,利于多客户端使用:@RestController=@ResponseBody+@Controller 2. 项目规范 在java文件中创建包 包名 存储类型 controller controller entity 实体类 mapper 接口类 util 工具类(返回类/实体类的一种) interceptor 拦截器 conf 拦截器String类 在resource文件中创建目录 目录名 存储类型 mappers 接口配置文件 4.JUnit 基础配置[不推荐]: 此处建议直接复制生成的测试文件,就不用了设置了 调用Spring文件 1@RunWitch(SpringRunner.class); 其他 1@SpringBootTest 自动装配对象 无需new就可以自动声明 12@AutowiredUserMapper mapper; 报错解决 步骤文件中@AutoWired错误或@MapperScan出错,导致找不到接口类; 1Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;cn.tedu.store.mapper.UserMapper&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; Mapper.xml中 id或者namespace属性出错,导致查找不到接口类的方法 1org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): cn.tedu.store.mapper.UserMapper.insert Mapper.xml中@param定义的和引用的数量不一样导致数组下标越界 1org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter &apos;#modifiedUser&apos; not found. Available parameters are [modifiedTime, modifiedUser, param3, aid, param1, param2] 1Caused by: java.sql.SQLException: Parameter index out of range (1 &gt; number o) mapper.xml中sql语句字段名出错 一大坨 123org.springframework.jdbc.BadSqlGrammarException: ### Error updating database. Cause: java.sql.SQLSyntaxErrorException: Unknown column '错误字段名' in 'field list'&lt;!--错误的字段名--&gt;### The error may exist in file [D:\\tts9\\workspace\\store\\target\\classes\\mappers\\UserMapper.xml]&lt;!--错误文件所在系统位置--&gt; mapper.xml中sql语句出错 一大坨 123org.springframework.jdbc.BadSqlGrammarException: ### Error updating database. Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' at line 1&lt;!--错误的位置--&gt;### The error may exist in file [D:\\eclipse_workspace\\store09\\target\\classes\\mappers\\AddressMapper.xml]&lt;!--错误文件在系统中的位置--&gt; Mapper.java中方法出错 1Caused by: java.lang.ClassNotFoundException: Cannot find class: 实体类中的某个属性错误 1Caused by: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;phone&apos; in &apos;class cn.tedu.store.entity.User&apos; junit报错,报错台无信息 测试类包名出错或者忘记写@Test 5.连接数据库 添加依赖 此时不添加数据源启动就会失败 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置数据源 配置resources下的application.properties文件 123spring.datasource.url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root Junn测试 用junit运行测试文件 在配置完数据源后,自动在test文件件中创建项目名ApplicationTest.java文件 主要用于检测依赖是否正常,正常的话不报错 自行测试 复制java文件 test 1234@AutoWiredDataSource datesource;Connection conn = dataSource.getConnection();syse(conn); 6.使用MyBatis 调用mapper.xml acclication.properties 1mybatis.mapper-locations=classpath:mappers/*.xml 创建实体类 可用于MyBatis的数据库使用 可用于AJAX做返回值使用 12345678public class User &#123; private String username; private String password; private Integer age; private String phone; private String email; 创建get/set/toString方法&#125; 扫描接口类 在接口类配置[不推荐,每一个都要配置] 123@Mapperpublic interface UserMapper &#123;&#125; 启动类配置 123@MapperScan(\"cn.tedu.boot.demo.mapper[,包2]\")//要扫描的包,类似spring.xmlpublic class DemoApplication&#123;&#125; 配置SQL语句 使用注解[不推荐,不利于维护] 12@insert(SQL语句)Integer insert(User user); 使用XML 跟MyBatis配置方式相同,在resources下新建mapper.xml文件 mapper.xml 12345&lt;mapper namespace=\"cn.tedu.boot.demo.mapper.UserMapper\"&gt; &lt;insert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; INSERT INTO t_user (username,password,age,phone,email,is_delete)VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;isDelete&#125;) &lt;/insert&gt;&lt;/mapper&gt; 测试 12345678910@Testpublic void insert()&#123; @Autowired UserMapper mapper; User user = new User(); user.setUsername(\"springboot\"); user.setPassword(\"8888\"); Integer rows = mapper.insert(user); System.err.println(\"rows\"+rows);&#125; 7.拦截器 新建拦截器类 指定拦截的规则:不符合规则的拦截,并转发到指定位置 123456789public class LoginInterceptor implements HandlerInterceptor &#123;//1.实现HandlerInterceptor类 @Override//2.生成preHandle方法 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception &#123; if(uid==null)&#123; return false; &#125; return true; &#125;&#125; 新建配置类 白名单和黑名单都可以传入List类型 123456789101112public class A implements WebMvcConfigurer&#123;//1.实现WebMvcConfigurer类 @Override//2.实现addIntercdptors方法 public void addInterceptors(InterceptorRegistry registry) &#123; HandlerInterceptor interceptor=new LoginInterceptor();//新建拦截器类对象 registry.addInterceptor(interceptor) .addPathPatterns(\"/**\")//白名单 .excludePathPatterns(patterns);//黑名单/* InterceptorRegistration x = registry.addInterceptor(interceptor); x.addPathPatterns(patterns); x.excludePathPatterns(patterns);*/ &#125;&#125; 8.实例流程下面配置建立在上面配置完数据库的情况下 创建实体类 见上文使用MyBatis--创建实体类 创建接口 UserMapper.java 123public interface UserMapper()&#123; User findByUsername(String username);&#125; 创建返回类(工具类) ResponseResult.java 123456private Integer state;private String message;生成get/set/toString方法生成无参构造器:防止框架找不到无参构造器报错生成有参数构造器:用于做返回类使用;生成只有state的有参构造器:值返回一个值时使用(灵活性,建议使用) 创建Mapper文件 UserMapper.xml 12345&lt;mapper&gt; &lt;select resultType=\"cn.tedu.boot.demo.entity.User\"&gt; SELECT id FROM t_user WHERE username = #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 修改Application.properties 见上文使用MyBatis 创建登录网页 reg.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;form&gt; &lt;h1&gt;用户注册&lt;/h1&gt; &lt;div&gt;请输入用户名&lt;/div&gt; &lt;div&gt;&lt;input name=\"username\"&gt;&lt;/div&gt; &lt;div&gt;&lt;span id=\"username-hint\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;请输入密码&lt;/div&gt; &lt;div&gt;&lt;input name=\"password\"&gt;&lt;/div&gt; &lt;div&gt;&lt;span id=\"password-hint\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;请输入年龄&lt;/div&gt; &lt;div&gt;&lt;input name=\"age\"&gt;&lt;/div&gt; &lt;div&gt;请输入手机号码&lt;/div&gt; &lt;div&gt;&lt;input name=\"phone\"&gt;&lt;/div&gt; &lt;div&gt;请输入电子邮箱&lt;/div&gt; &lt;div&gt;&lt;input name=\"email\"&gt;&lt;/div&gt; &lt;div&gt;&lt;input id=\"btn-reg\" type=\"button\" value=\"注册\"&gt;&lt;/div&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" src=\"jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(\"btn-reg\").click(function()&#123; $(\"#username-hint\").html(\"\");//防止第二次校验失效 $(\"#password-hint\").html(\"\"); $ajax(&#123; \"url\":\"user/reg\", \"data\":$(\"#from-reg\").serialize(), \"type\":\"post\", \"dataType\":\"json\", \"success\":function(json)&#123; if(json.state==1)&#123; alert(\"注册成功\"); &#125;else if(json.state==2)&#123; $(\"#username-hint\").html(json.message); &#125;else&#123;//此处无需设置 $(\"#password-hint\").html(json.message); &#125; &#125; &#125;) &#125;)&lt;/script&gt; 创建controller Controller.java 123456789101112131415@RestControlle//设置ajax:相当于不返回给处理器;而返回给发送数据的html文件@RequestMapping(\"user\")public class UserController&#123; @Autowired//自动装配接口类,MVC不需要调用Spring文件 private UserMapper userMapper @RequestMapping(\"reg\") public String reg(User user)&#123;//传入了一个User,前面都没有类似操作,可以直接传入数据 User user = userMapper.finByUsername(); if(user == null)&#123;//测试是要注册的用户名是否已存在 return new ResponseResult(1);//只有state的构造器 &#125;else&#123; return new ResponseResult(2),\"用户名已经被占用\"; &#125; &#125;&#125; 直接访问127.0.0.1:8080即可","categories":[{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/categories/Spring/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"https://airbash.cn/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://airbash.cn/tags/SpringBoot/"}]},{"title":"AJAX","slug":"前端/AJAX","date":"2019-11-02T12:39:45.000Z","updated":"2019-11-06T03:36:22.449Z","comments":true,"path":"2019/11/02/前端/AJAX/","link":"","permalink":"https://airbash.cn/2019/11/02/%E5%89%8D%E7%AB%AF/AJAX/","excerpt":"","text":"1. AJAX1.基础内容 实现功能: 在不转发和重发的情况下处理页面(异步) 基础配置: 配置tomcat 设置spring-mvc依赖 字符集.自动查找 2.$.ajax参数 参数名 内容 注意事项 url 访问地址 data 发送表单数据(不写时代表接收数据)new FormData($(“#form”[0]) type 请求方法:get/post(与服务器控制层一致) dataType 服务器return类型:json/xml/text/html 不指定时自动识别 success 成功响应时(响应码为2XX时)的处理函数 error 失败时响应(响应吗为2XX以外)的处理函数 contentType:false 上传 contentData:false 上传 error在项目中通常只处理3XX错误(400X/500X项目中不应该出现) 3.JQ代码1234567891011121314151617$(\"#btn-login\").click(function()&#123; $.ajax(&#123; \"url\":\"user/login.do\", \"data\":\"username=\"+$(\"#username\").val()+\"&amp;password=\"+$(\"#password\").val(), \"type\":\"post\", \"dataType\":\"json\", \"success\":function(json)&#123; if(json.state == 1)&#123; alert(json.message); &#125;else if(json.state ==2)&#123; alert(json.message); &#125;else&#123; alert(json.message); &#125; &#125; &#125;);&#125;); 2. JSON1.语法 标签名\\文本都要加双引号 标签名右侧冒号[+文本] 父标签后加大括号 文本中String类型需要加双引号,int类型不需要加双引号 2.与xml的比较 xml 12345&lt;state&gt;1&lt;/state&gt;&lt;data&gt; &lt;username&gt;root&lt;/username&gt; &lt;age&gt;18&lt;/age&gt;&lt;/data&gt; json 1234567 &#123; \"state\":1, \"data\":&#123; \"username\":\"root\", \"age\":18 &#125;&#125; 3.Json中的数组 数组: 123456&#123; \"state\":1, \"data\": [ \"Mike\", \"Jack\", \"Lucy\" ]&#125; 数组中包含对象 1234567891011121314151617&#123; \"state\":1, \"data\": [ &#123; \"username\":\"Mike\", \"age\":23 &#125;, &#123; \"username\":\"Jack\", \"age\":21 &#125;, &#123; \"username\":\"Lucy\", \"age\":25 &#125; ]&#125; 4.javascriptjson可以被javascript直接识别,json.parse(str) 123456789101112131415161718192021var json = &#123; \"state\":1, \"message\":\"欢迎使用JSON\", \"data\":[ &#123; \"username\":\"Mike\", \"age\":23 &#125;, &#123; \"username\":\"Lucy\", \"age\":21 &#125;, &#123; \"username\":\"jack\", \"age\":22 &#125; ]&#125;;for(var i=0;i&lt;json.data.length;i++)&#123; alert(json.data[i].username);&#125; 3. springMVC整合1.服务器响应String类型1.英文类型 controller.java 只注解@ResponseBody即可,可以和@controller合并为@RestController 123456789101112131415161718@Controller@RequestMapping(\"user\")public class UserController &#123; @RequestMapping(\"login.do\") @ResponseBody//默认不支持utf-8,添加json依赖后支持 public String handleLogin( String username, String password) &#123; if (\"root\".equals(username)) &#123; if (\"1234\".equals(password)) &#123; return \"OK\"; &#125; else &#123; return \"error\"; &#125; &#125; else &#123; return \"error\"; &#125; &#125;&#125; 测试 只要是将数据发送给controller并转到croller页面就会发生打印现象 访问当下地址http://localhost:8080/spring-10-ajax/user/login.do?username=root&amp;password=1234; from接收后; 结果 ​ 添加后不转换地址,可以吧return直接输入到页面上 2.中文类型 原理: 相当于在html添加数据,而html响应头默认为8859-1类型的,因此需要修改默认字符集才能在页面上显示中文,否则乱码 方法1: 修改@ResponseBody为@ResponseBody(text/html;charset=UTF-8) 方法2: 1234567891011&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 2. 服务器响应JSON格式的结果 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 注解驱动 jackson必须在spring.xml中添加驱动才能起作用 在添加@ResponseBody注解以后只能return英文,注解驱动后可以return中文,并且可以return”json” 中文原理:将响应头改为:application/json; charset=UTF-8 1&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 创建实体类 12345public class ResponseResult &#123; private Integer state; private String message; // 某些构造方法/SET/GET&#125; controller类 @ResponseBody//启用AJAX:默认不支持utf-8,添加json注解后支持 123456789101112131415161718@Controller@RequestMapping(\"user\")public class UserController &#123; @RequestMapping(\"login.do\") @ResponseBody//默认不支持utf-8,添加json注解后支持 public String handleLogin( String username, String password) &#123; if (\"root\".equals(username)) &#123; if (\"1234\".equals(password)) &#123; return new AAA(1,\"登录成功\"); &#125; else &#123; return new AAA(3,\"密码错误\"); &#125; &#125; else &#123; return new AAA(2,\"账号错误\"); &#125; &#125;&#125; 页面显示结果 访问user/login.do 1&#123;\"state\":1,\"message\":\"登录成功\"&#125; 转换器 在响应正文的过程中需要使用转换器Converter: 返回值类型String:StringHttpMessageConverter转换器 无法识别时:jackson转换器 4. 前端页面 解决方案: 通过取消form表单的提交功能 删除form标签 使用button html 12345678&lt;form method=\"post\" action=\"handle_login.do\"&gt; &lt;h1&gt;用户登录&lt;/h1&gt; &lt;div&gt;请输入用户名&lt;/div&gt; &lt;div&gt;&lt;input name=\"username\" /&gt;&lt;/div&gt; &lt;div&gt;请输入密码&lt;/div&gt; &lt;div&gt;&lt;input name=\"password\" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input id=\"btn-login\" type=\"button\" value=\"登录\" /&gt;&lt;/div&gt;&lt;/form&gt; jQuery 123456&lt;script type=\"text/javascript\" src=\"jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(\"#btn-login\").click(function()&#123; alert(\"hello, jquery!\"); &#125;);&lt;/script&gt; 写在文档的最后面.或者使用下列代码 12345&lt;script&gt; $(document).ready(function()&#123; $(\"#btn-login\").click(); &#125;); //网页全部加载完之后再执行&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://airbash.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/tags/Spring/"},{"name":"框架","slug":"框架","permalink":"https://airbash.cn/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"MyBatis","slug":"Spring/MyBatis","date":"2019-11-02T12:26:35.000Z","updated":"2019-11-06T03:36:22.444Z","comments":true,"path":"2019/11/02/Spring/MyBatis/","link":"","permalink":"https://airbash.cn/2019/11/02/Spring/MyBatis/","excerpt":"","text":"三.MyBatis配置依赖 添加MyBatis的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 添加MyBatis与Spring整合依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 添加JDBC相关的Spring 版本必须与当前项目使用的spring-webmvc的版本完全相同。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; 添加MySQL驱动和数据库连接池的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; Junit内注解测试 123456789101112&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 123@RunWith(SpringRunner.class)@ContextConfiguration(locations=&#123;\"classpath:spring.xml\"&#125;)@ContextConfiguration(locations= &#123;\"classpath*:spring.xml\",\"classpath*:spring_redis.xml\"&#125;) 数据库流程1. 配置并读取数据库文件[之前写过] 配置数据库文件 db.properties 123456url=jdbc:mysql://localhost:3306/tedu_umsuseUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaidriver=com.mysql.jdbc.Driverusername=rootpassword=rootinitialSize=2maxActive=10 spring.xml 1&lt;util:properties id=\"dbConfig\" location=\"classpath:db.properties\" /&gt; 2.连接数据库 spring.xml 直接在BasicDataSource中查找属性; 建立BasicDataSource与数据库配置文件之间的联系; name:BasicDataSource;value:数据库配置文件 12345678&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"url\" value=\"#&#123;dbConfig.url&#125;\" /&gt; &lt;property name=\"driverClassName\" value=\"#&#123;dbConfig.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"#&#123;dbConfig.username&#125;\" /&gt; &lt;property name=\"password\" value=\"#&#123;dbConfig.password&#125;\" /&gt; &lt;property name=\"initialSize\" value=\"#&#123;dbConfig.initialSize&#125;\" /&gt; &lt;property name=\"maxActive\" value=\"#&#123;dbConfig.maxActive&#125;\" /&gt;&lt;/bean&gt; *测试连接数据库12345678@Testpublic void getConnection() throws SQLException &#123; AbstractApplicationContext ac = new ClassPathXmlApplicationContext(\"spring.xml\"); BasicDataSource dataSource = ac.getBean(\"dataSource\", BasicDataSource.class); Connection conn = dataSource.getConnection(); System.out.println(conn); ac.close();&#125; 3. 持久层接口 创建实体类 用于被接口调用,并向其添加用于添加数据库的字段值 1234public class User&#123; private 数据类型 属性名; 生成get/set/toString方法&#125; 创建持久层接口 调用User类,用于向数据库中添加记录 增删改时返回值用 Insteger:用于返回修改的条目 123public interface UserMapper()&#123; Integer insert(User user);&#125; 扫描持久层接口 123&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.tedu.mybatis\" /&gt;&lt;/bean&gt; 4. 映射Sql语句 下载并使用mapper.xml文件 mapper.xml基础内容 123&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt; 配置执行命令 mapper.xml 123456789101112131415&lt;mapper namespace=\"cn.tedu.mybatis.UserMapper\"&gt; &lt;insert id=\"持久接口方法名\"&gt;//节点错误时依然生效,但是返回值出错 INSERT INTO t_user ( &lt;!--属性顺序可以与mysal字段循序不一致,必须与musal字段名一致,可以与user属性不相同但是必须对应--&gt; username, password, age, phone, email ) VALUES ( &lt;!--user属性名 --&gt; #&#123;username&#125;,#&#123;password&#125;, #&#123;age&#125;,#&#123;phone&#125;, #&#123;email&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 调用并执行mapper.xml文件 spring.xml 直接在SqlSessionFactoryBean中配置 123456&lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 数据源:连接与数据源的关系:BasicDataSource--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- XML位置 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mappers/*.xml\" /&gt;&lt;/bean&gt; *测试添加条目 注意事项: Spring能创建接口对象(通过代理对象的方法) 在Spring中可以通过set方法/自己书写/接收表单数据接收数据 默认spring只创建对象,但是不执行里面的方法 java 12345678910111213@TESTUserMapper userMapper = ac.getBean(\"userMapper\", UserMapper.class);//也可以在Spring.xml文件中配置//User user = ac.getBean(\"user\",User.class);User user = new User();user.setUsername(\"admin\");user.setPassword(\"1234\");user.setAge(18);user.setPhone(\"12345678901\");user.setEmail(\"admin@tedu.com\");//方法默认不执行,因此需要手动调用方法Integer rows = userMapper.insert(user);System.out.println(\"rows=\"+rows); 基础操作1. 查询​ @insert(sql语句) 思路 思路1:直接在xml上配置值;[不建议使用,不能复用] 思路2:在街口抽象方法上加入参数: 思路2.1:参数类型是String 思路2.2:参数类型User[不生效] 思路2:在接口抽象方法上加入参数(可以复用); 思路2.1:返回值类型是String[推荐] 思路2.2:返回值类型是User[User内的参数要包含查询语句参数] 注意事项 resultType是接口类返回值类型的类地址(数组类型是单个类型的地址) 返回值类型可以是任意的,resultType在写lang类型时可以省略 除了添加数据以外其余的不能使用java实体类传入数据 查询整个列表 接口类 1List&lt;User&gt; findAll()；//配置一个抽象方法,返回值为列表 mapper.xml 123&lt;select id=\"对应抽象方法\" resultType=\"返回实体类地址\"&gt; SELECT * FROM t_user &lt;/select&gt; test 123for(User user : list)&#123; system.out.println(user.toString());&#125; 查询一条数据 接口类 1User findOne(String username)；// mapper.xml 1234&lt;select id=\"findOne\"&gt; SELECT username FROM t_user WHERE username=#&#123;username&#125;; &lt;!--#&#123;&#125;内代表传入的值,接口值默认传入--&gt;&lt;/select&gt; test 12User user = userMapper.findByUsername(\"root\");system.out.println(user); 查询单个字段值 2. 接口名称和字段名称不相同​ 通常情况下不会有增加字段操作,因此个人不推荐这种做法 执行mysql命令增加新字段[只能在mysql中执行命令添加] 1alter table t_user add column is_delete int; 实体类[额外操作] 12private Integer isDelese;增加get set方法,重新修改toString方法 接口类[额外操作] 1Integer addAlter();//返回这类型Integer:是否成功;参数列表:不添加不用写 mapper.xml[额外操作] 修改之前用到字段名的标签,增加没有写的新字段 1234567891011&lt;insert id=\"持久接口方法名\"&gt;//节点错误时依然生效,但是返回值出错 INSERT INTO t_user ( username, password, age, phone, email,is_delete&lt;!--字段名称--&gt; ) VALUES ( #&#123;username&#125;,#&#123;password&#125;, #&#123;age&#125;,#&#123;phone&#125;, #&#123;email&#125;,#&#123;isDelete&#125;&lt;!--属性名称--&gt; )&lt;/insert&gt; 注意事项: 出现问题 当出现了字段名与实体类中的属性名不一致时,查询时的字段值显示为null 解决方法 不能使用select * 了,因为不能添加别名,生产情况中*不常用 123&lt;select id=\"findAll\" resultAll=\"cn.tedu.mybatis.User\"&gt; select username, password, age, phone, email,is_delete as isDelete from t_user;&lt;/select&gt; 3. 更新字段值 接口类 1Integer updateIsDelete(Integer isDelete); mapper.xml 123&lt;update id=\"updateIsDelete\"&gt; UPDATE t_user SET is_delete = #&#123;isDelete&#125;&lt;/update&gt; Test 1234@Testpublic void a()&#123; Integer rows = 接口类对象.updateIsDelete(0);&#125; 4.传入多个参数 常规思路[错误的演示] 接口类 1Integer updateUandP(String username,String password); mapper.xml 123&lt;update id=\"updateUandP\"&gt; UPDATE t_user SET password = #&#123;password&#125; WHERE USERNAME = #&#123;username&#125;&lt;/update&gt; test 1234@Testpublic void updateUandP()&#123; Integer rows = 接口对象.updateUandP(\"root\",\"123456\");&#125; 错误提示 12Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;password&apos; not found. Available parameters are [arg1, arg0, param1, param2] 原因MyBatis框架只识别一个参数:默认传入四个参数,三个是框架用的不可见,一个是用户使用的, 使用Map传入两个参数[不完善,不推荐] 必须知道map传入了几个数值,传入的类型,局限性太大,太麻烦因此不推荐 接口类 1Integer updateUandP(SMap map); mapper.xml 参数名必须与map中键名相同 123&lt;update id=\"updateUandP\"&gt; UPDATE t_user SET password = #&#123;password1&#125; WHERE USERNAME = #&#123;username1&#125;&lt;/update&gt; test 1234567@Testpublic updateUandp2()&#123; Map map = new HashMap&lt;String,Object&gt;(); map.put(\"password1\",\"longda101\"); map.put(\"username1\",\"root103\"); Integer rows = 接口对象.updateUandP2(map);&#125; 注解 接口类 1Integer updateUandP3(@param(\"username3\") String password3,@Param(\"password3\") String password3); mapper.xml 参数名必须与map中键名相同 123&lt;update id=\"updateUadnp3\"&gt; UPDATE t_user SET password = #&#123;password3&#125; WHERE USERNAME = #&#123;username3&#125;&lt;/update&gt; test 1234@Testpublic updateUandp3()&#123; Integer rows = 接口对象.updateUandP3(\"root103\",\"longdan103\");&#125; 5. 获取新增记录的自增长ID 接口类 1Integer insertAutoId(); mapper.xml useGeneratedKeys=”true”:启动获取新增记录自增长ID keyProperty=”参数名”:返回到实体类对象的一个参数值中,替换原来的值 123&lt;insert useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; INSERT INTO t_user(username,password) VALUES(#&#123;username&#125;,#&#123;password&#125;)&lt;/insert&gt; test 两次ID的值不一样,第二次为返回的值 123456789@Testpublic void insertAutoId()&#123; User user = new User(); user.setUsername(\"rootx\"); user.setPassword(\"rootx\"); syso(user.getID());//此时user中的ID为X Insert rows = 接口对象.insertAutoID(); syso(user.getID());//此时user中的ID为Y&#125; 6.统计当前数据库中数据的数量​ 类似于思路2.1的方法 接口 1Integer countID(); mapper.xml 123&lt;select id=\"countID\" resultType=\"Integer\"&gt; SELECT COUNT(id) FROM t_user;&lt;/select&gt; test 12345@Testpublic void countID()&#123; Integer countID = userMapper.countID(); System.out.println(countID);&#125; 7. 多表关联查询​ 因为没有能与关联查询相匹配的实体类,因此我们在这里使用VO类 新建VO类 12345public void UserVO()&#123; user类属性 department类属性 生成get/set/toString方法&#125; 接口 1List&lt;UserVO&gt; findAll2(); mapper.xml 123&lt;select id=\"findAll2\" resultType=\"cn.tedu.mybatis.UserVO\"&gt; SELECT t_user.id, username,password, age,is_delete AS isDelete,department_id,name FROM t_user LEFT JOIN t_department ON t_user.department_id=t_department.id&lt;/select&gt; test 1234List&lt;UserVO&gt; list = userMapper.findAll2(); for(UserVO userVO : list)&#123; System.out.println(userVO);&#125; 动态SQL​ 目前理解为参数为多个相同类型,不能直接传或者map或者@param 1. &lt;foreach&gt;标签 属性 作用 选项 状态 collection 传入类型 list/array/map/set 必选 item 别名,相当于id键 必选 index 迭代次数,值 可选 separator 为传入的数据之间添加分隔符 “,” 可选 open foreach开启之前的sql语句 “(“ 可选/[不推荐] close foreach开始之后的sql语句 “)” 可选/[不推荐] sql语句 1DELETE FROM t_user WHERE id IN (2,4,5); 接口 因为是多个相同类型,这里建议用数组或者集合 1Integer deleteByIDs(Integer[] ids);//数组 mapper.xml 内容 123456&lt;delete id=\"deleteByIDs\"&gt; DELETE FROM t_user WHERE id IN &lt;foreach collection=\"array\" item=\"id\" separator=\",\" open=\"(\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/delete&gt; 详解 123for(Integer item : (collection)ids)&#123; System.out.print(item);&#125; test 123456@Testpublic void DeleteByID()&#123; Integer[] ids = &#123;3,5,7&#125;; Integer rows = userMapper.deleteByIDs(ids); System.out.println(rows;&#125; 2. &lt;if&gt;标签 抽象类 1List&lt;User&gt; findIf(@pParam(\"where\") String whereX); mapper.xml 12345678&lt;select id=\"findIf\"&gt; SELECT * FROM t_user &lt;if test=\"where != null\"//if WHERE $&#123;where&#125; &lt;/if&gt; &lt;if test=\"where == null\"&gt;//else,在本题目中可以不写 &lt;/if&gt;&lt;/select&gt; test 在传入值是一个参数时用#{},当传入值是一段话时用${} JDBC中的?处理一个参数时不用加引号,因为是预编译,预编译不支持引号,即便是or语句也会识别成一个参数,因此在这里不能用#{},只能使用${} 1234567891011121314@Testpublic void findIf()&#123; syso(\"where != null\"); String whereX = \"username = 'root'\"; List&lt;User&gt; list1 = 接口类对象.findIf(whereX); for(User user : list1)&#123; syso(user); &#125; syso(\"where == null\"); List&lt;User&gt; list2 = 接口类对象.findIf(whereX); for(User user: list2)&#123; syso(user); &#125;&#125; resultMap​ 将查询到的结果封装到对象中 错误的演示[错误] 新建VO类 123private Integer id;private String name;private List&lt;User&gt; user;//此处引用了一个对象,而不是对象内的属性 接口 1DepartmentVO findById(Integer id); mapper.xml 123&lt;select id=\"findById\" resultType=\"cn.tedu.myBatis.DepartmentVO\"&gt; SELECT t_department.id AS did,t_department.name,t_user.id AS uid,username, password,age, phone,email, is_delete,department_id FROM t_department LEFT JOIN t_user ON t_department.id=t_user.department_id WHERE t_department.id=#&#123;id&#125;;&lt;/select&gt; 错误提示 因为在VO类中引用了User对象,而在返回时查询到的数据不能封装到User对象中,因而报错 1Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 resultMap节点 需要封装到对象中的数据写在collection子节点中,不需要的直接写在resultMap节点中 节点 作用 注意 id id名 resultMap属性 type 查询返回值类型地址 resultMap属性 collection 用于配置1:N关系的数据(需要封装到对象中的数据) resultMap子节点 ofType 集合中的元素的类型地址 collection属性 id 用于配置主键字段的值的封装 collection子节点/resultMap子节点 result 用于配置非主键字段的封装 collection子节点/resultMap子节点 column mysql查询的字段名(有别名时为别名) id/result属性 property 要封装的属性名 id/result属性 注意事项 此处属性值和字段名不相同时不需要写别名,只有在单纯查询时需要写,这里的resultMap已经写了关系,所以不用写 select的resultType节点改为resultMap节点 可以只使用result,而不使用id,但是推荐使用,因为mybatis会基于id的配置查询结果的缓存 当有两个相同的属性值时(正常属性值和导入属性值相同时)需要修改别名 添加&lt;catch/&gt;可以进行缓存,增删改删除缓存,缓存方便查找,因此经常增删改不应该加缓存 正确的方法 节点 1DepartmentVO findById(Integer id); mapper.xml 123456789101112131415161718&lt;select id=\"findById\" resultMap=\"DepartmentVO_Map\"&gt;//使用新节点 SELECT t_department.id AS did,t_department.name,t_user.id AS uid,username, password,age, phone,email, is_delete,department_id FROM t_department LEFT JOIN t_user ON t_department.id=t_user.department_id WHERE t_department.id=#&#123;id&#125;;&lt;/select&gt;&lt;resultMap id=\"DepartmentVO_Map\" type=\"cn.tedu.mybatis.DepartmentVO\" &gt; &lt;id column=\"did\" property=\"id\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;collection property=\"需要封装到的对象名\" ofType=\"cn.tedu.mybatis.User\"&gt; &lt;id column=\"uid\" property=\"id\" /&gt; &lt;result column=\"username\" property=\"username\" /&gt; &lt;result column=\"password\" property=\"password\" /&gt; &lt;result column=\"age\" property=\"age\" /&gt; &lt;result column=\"phone\" property=\"phone\" /&gt; &lt;result column=\"email\" property=\"email\" /&gt; &lt;result column=\"is_delete\" property=\"isDelete\" /&gt; &lt;result column=\"department_id\" property=\"departmentId\" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; test 12DepartmentVO departmentVO = departmentMapper.findById(3);System.out.println(departmentVO);","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://airbash.cn/categories/MyBatis/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/tags/Spring/"},{"name":"框架","slug":"框架","permalink":"https://airbash.cn/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringMVC","slug":"Spring/SpringMVC","date":"2019-11-02T12:21:58.000Z","updated":"2019-11-06T03:36:22.446Z","comments":true,"path":"2019/11/02/Spring/SpringMVC/","link":"","permalink":"https://airbash.cn/2019/11/02/Spring/SpringMVC/","excerpt":"","text":"1. 基础知识1.作用解决了V-C交互的问题。servlet 在传统的Java EE项目中，使用的Controller是Servlet，在绝大部分时候，用户的每个请求都需要1个Servlet进行处理，那么，在一个比较成熟的项目中，就需要创建大量的Servlet，则会引发一系列的问题：类太多不易于管理和维护；对象太多消耗内存；关于Servlet的配置代码太长也不易于管理和维护！ 2.创建项目 创建简单maven并生成web.xml文件 在项目中添加tomcat运行环境 在pom.xml中添加依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.核心组件 分类 组件 作用 DispatcherServlet 接收并分发所有请求给对应控制器(前端控制器,不处理请求) HandlerMapping 记录和制定分发方案(记录和处理请求路径与控制器的对应关系) Controller 实际处理请求生成ModeAndView ModeAndView 处理后的数据和视图名称 ViewResolver 通过接收到的视图名称确定响应的视图组件 流程图 Controller注解 注解 名称 @Component 通用注解 @Controller 控制类注解 @Service 业务类注解 @Repository 持久层类 2. MVC流程1. DispatcherServlet\\HandlerMapping 作用 项目启动时就直接初始化Spring.xml文件,不需要再使用Classpathxmlapplicationcontext进行调用. 配置了默认servlet默认转发类型.do. web.xml contextConfigLocation可以在class的父类里找到这一属性名 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--DispatcherServlet--&gt; &lt;!--初始化servlet时调用Spring.xml文件--&gt; &lt;init-param&gt;&lt;!--HandlerMapping:基于注解的HandlerMapping--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:Spring.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动时创建servlet,直接初始化,不能写在前面--&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;!--配置所有路径都被servlet处理,配置后的地址不能被访问&gt;&lt;/servlet-mapping&gt; 测试 启动时自动创建Component对象 123456@Componentpublic class User &#123; public User() &#123; System.out.println(\"User()\"); &#125;&#125; 2. Controller\\ModelAndView相当于servlet,返回值是ModelAndView String.xml controller扫描 1&lt;context:component-scan base-package=\"cn.tedu.包名\"&gt;&lt;/context:component-scan&gt; java 123456789101112131415161718/***1. 权限：无所谓，但是，应该使用public*2. 方法名：自定义*3. 参数：暂无[可以是接收表单或AJAX数据]*4. 返回值：返回[数据和]视图名. null:自动查找与RequestMapping名相同的文件 String:查找与文件名相同的文件*5.@RequestMapping:用于映射地址和控制器 return:用于映射控制器和文件*/@controllerpublic class userController&#123; @RequestMapping(\"hello.do\") public String showHello() &#123; syso(\"内容\"); return \"hello\";//modelAndView &#125;&#125; 测试 当访问hello.do时控制台输出”内容”; 3.ViewResolver决定位置 原理: 创建一个InternalResourceViewResolver对象(之前是自己写一个类然后创建) 默认根目录是webapp,引导到/前缀/return返回值.后缀(/WEB-INF/hello.jsp) 抽象类不能被直接使用,因此使用的是继承VIewResolver接口的子类 Spring.xml ​ prefix/suffix是InternalResourceViewResolver父类的属性 123456&lt;context:component-scan base-package=\"cn.tedu.spring\"&gt;&lt;/context:component-scan&gt;&lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/\" /&gt;//前缀 &lt;property name=\"suffix\" value=\".jsp\" /&gt;//后缀&lt;/bean&gt; 测试 访问hello.do,根据返回值访问网页,最后结果 3. 响应处理结果1.重定向12345678910111213//访问handle_reg.do----login.do//登录@RequestMapping(\"login.do\")public String showLogin()&#123; System.out.println(\"login\"); return \"login\";&#125;//处理注册:重定向@RequestMapping(\"handle_reg.do\")public String handleRegister()&#123; System.out.println(\"handle_reg\"); return \"redirect:login.do\";&#125; 2.转发 正常情况 123456789101112@RequestMapping(\"handle_login.do\")public String handleLogin(String username,String password,ModelMap modelMap)&#123; if()&#123; String message=\"1\"; return \"login\"; &#125;else&#123; String message=\"0\"; return \"error\"; &#125; modelMap.addAttribute(\"msg\",message); return \"\";&#125; ModelAndView[不推荐] 1234567891011@RequestMapping(\"handle_login.do\")public ModelAndView handleLogin(String username,String password)&#123; if()&#123; String message = \"1\"; return \"login\"; &#125;else&#123; String message = \"0\"; return \"herror\"; &#125; return \"\";&#125; 3.session java 12345678910@RequestMapping(\"reg.do\")public String register(HttpSession session)&#123; Object count = session.getAttribute(\"count\"); if(count==null)&#123; count = 1; &#125;else&#123; count = (Integer)count+1; &#125; session.setAttribute(\"count\");&#125; 4. @RequestMapping[设置目录] 设置父目录 12345678@Controller@RequestMapping(\"User\")//当配置进制只允许提交方式时必须用[value=\"User\"]public class User&#123; @RequestMapping(\"login.do\") public String login()&#123; return \"\"; &#125;&#125; 设置只允许使用某种提交方式 使用别的提交方式会提示405错误 12345678@Controller@RequestMapping(value=\"User\" method=RequestMethod.POST)//只允许使用POSTpublic class User&#123; @RequestMapping(\"login.do\") public String login()&#123; return \"\"; &#125;&#125; postMapping 在方法上用postMapping 5. @RequestParam(参数命名) 使用情况 客户端的名字跟程序的不一样时 必须添加某一个参数时 需要添加默认值时[非默认] 设置别名 123public String handleLogin(@RequestParam(\"uname\") String username,String password)&#123; //当提交的表单中的名字为uname时也可以,但是必须提交否则400错误&#125; 设置不必须添加参数 默认有一个隐式required=true 1@RequestParam(value=\"uname\",required=false) 设置默认值 1@RequestParam(value=\"uname\",required=false,defaultValue=\"\") 4.拦截器 详细内容 拦截器是SpringMVC的组件,用于拦截或者放行 preHandle方法中定义if满足条件时返回下列 return=true时:拦截器放行; return=flase时:拦截器拦截;剩余的两个方法执行:postHandlle()/afterCompletion() 仅能拦截Dispatcher所配置的文件 例子:若dispatcher仅配置了*.do文件,那么.jsp文件不经过MVC,因此不能拦截; xml配置:拦截器(拦截器的url路径/拦截器规则所在类) 通配符 通配符 作用 案例 * 代表拦截层数 /user/* 可以拦截/user/a.jsp /user/**可以拦截/user/a.jsp和/user/a/a.jsp ? 代表拦截文件[不常用] /user/????.jsp 黑名单 多个拦截器时,生效顺序取决于拦截器的书写顺序 12345678910&lt;!-- 配置拦截器链 --&gt;&lt;mvc:interceptors&gt; &lt;!--拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!-- 拦截路径 --&gt; &lt;mvc:mapping path=\"需要拦截url地址\"/&gt; &lt;!-- 拦截器类--&gt; &lt;bean class=\"java配置的所在类\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 白名单+黑名单[简易] 白名单上的路径不经过拦截器,直接进入controller 1234567891011121314&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 1：父类下的全部为黑名单 --&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!-- 2：父类下的例外/白名单 --&gt; &lt;mvc:exclude-mapping path=\"/user/reg.do\"/&gt; &lt;mvc:exclude-mapping path=\"/user/register.do\"/&gt; &lt;mvc:exclude-mapping path=\"/user/login.do\"/&gt; &lt;mvc:exclude-mapping path=\"/user/handle_reg.do\"/&gt; &lt;mvc:exclude-mapping path=\"/user/handle_login.do\"/&gt; &lt;!-- 3：拦截器类 --&gt; &lt;bean class=\"cn.tedu.spring.拦截器类名\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器类:拦截器规则[,以及是否拦截] 需要实现HandleServletInterceptor类,并重写preHandle方法 12345678public boolean preHandle(HttpServletRequest request,HttpServletResponse response, Object handler)throws Exception &#123; if(不满足条件)&#123; response.sendRedirect(\"/web/login.html\");//重定向到一个网站 return false;//不放行:不可以访问 &#125;else&#123; return true;//放行:可以访问 &#125;&#125; 5.解决乱码 javaEE方法失效 javaEE中是在servlet之前生效,现在是在Controller之前生效,所以会导致失败 web.xml 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 6.访问静态资源1.&lt;mvc:resources /&gt;spring3.0.4之后新功能,与test测试冲突 spring.xml 1&lt;mvc:resources mapping=\"/**\" location=\"/\" /&gt; mapping:—&gt;location,可以使用classpath *:当前目录 **:当前目录及子目录 2.defaultServlet[推荐]Tomcat自带功能 web.xml 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3.&lt;mvc:default-servlet-handler /&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/categories/Spring/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/tags/Spring/"},{"name":"框架","slug":"框架","permalink":"https://airbash.cn/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring基础","slug":"Spring/Spring基础","date":"2019-11-02T12:11:32.000Z","updated":"2019-11-06T03:36:22.447Z","comments":true,"path":"2019/11/02/Spring/Spring基础/","link":"","permalink":"https://airbash.cn/2019/11/02/Spring/Spring%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1.基础知识1.基础配置 添加依赖: pom.xml:测试类,不包含mvc功能 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 复制spring(applicationContext).xml文件 2.注意事项 接口—父类—子类 123456781.接口 ApplicationContext ac = new ClassPathXmlApplicationContext(\"Sping.xml文件名\");//不能close2.接口实现类(父类) AbstractApplicationContext ac = new ClassPathXmlApplicationContext(\"Sping.xml文件名\");3.子类(原始) ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"Sping.xml文件名\"); 第一个单词+简写(alt+/) 尽量使用方法不使用强转,而使用方法,因为方法可能会升级 运用反射的技术进行操作:反射无视访问权限 控制反转 控制反转:Spring获取已经创建好的对象;(可以创建对象，称为Spring控制对象，也称为IOC控制反转.) 主动控制:直接new对象; 2.Spring IOC容器使用IOC实例化javaBean的流程 1.创建javaBean:实体类 创建步骤 必须在包(package)内创建 实现Serializable序列化接口(暗中添加三个方法) 书写无参构造器(如果有构造器的话) 可以是默认构造器 方便子类的继承 创建get/set/toString定义”Bean属性”; java 123456class User&#123; String Name;//实例变量:对象属性 public String getName()&#123;&#125;//Bean属性:name public String setName()&#123;&#125;//Bean属性:name toString();&#125; 2.实例化(创建javaBean对象)让Spring框架在启动的时候自动创建DemoBean的实例,并绑定ID为demoBean id与name功能一样 1.xml标签 Bean标签列表 代码 功能 注意事项 class javaBean文件所在位置 id javaBean被实例化时的名称 与name功能相同; name javaBean被实例化时的名称 与id功能相同; factory-method=”方法” 工厂方法初始化时执行方法 factory-bean=”Bean对象” 工厂方法初始化Bean创建对象 init-method 初始化方法 Spring会在容器启动时候，创建Bean对象，并且执行init()方法 destroy-method 销毁方法 Spring会在关闭容器时候，销毁Bean对象，并且执行destroy()方法/仅在单例时有效 scope=”prototype” 建立多个Bean实例,每次调用GetBean时候都会创建一个新对象 默认情况下,Spring中Bean是”单例”的(自始而终,singletion,并且创建的对象时同一对象) lazy-init=”true”; 懒惰初始化 适合很少使用的对象 单例的Java在容器启动时立即初始化,反应快,性能好,占用资源高. 懒惰初始化不是立即生效 alias标签:设置别名 1&lt;alias name=\"Bean名\" alias =\"别名\" /&gt;//没有id选项只有name选项 2.Spring IOC创建对象三种方法​ 只能对spring.xml配置的文件进行实例化,不能实例化@server相关的 使用无参数构造器创建对象： 1&lt;bean id=\"demoBean\" class=\"day01.DemoBean\"&gt;&lt;/bean&gt; 调用类的静态工厂方法创建对象： 1&lt;bean id=\"calender\" class=\"java.util.Calendar\" factory-method=\"getInstance\"&gt;&lt;/bean&gt; 调用对象的工厂方法创建对象： 调用了2中的Bean[不推荐] 1&lt;bean id=\"date\" factory-bean=\"calender\" factory-method=\"getTime\"&gt;&lt;/bean&gt; 直接书写 123&lt;bean id=\"userServiceImpl\" class=\"cn.tedu.service.UserServiceImpl\"&gt;&lt;/bean&gt; //&lt;constructor-arg type = \"String\" value = \"key\" /&gt;传递参数&lt;bean id=\"user\" factory-bean=\"userServiceImpl\" factory-method=\"findAll\"/&gt;&lt;/bean&gt; 3.调用 导入Spring配置文件(applicationContext文件,启动、初始化Spring容器) 1AbstractApplicationContext ac = new ClassPathXmlApplicationContext(\"spring配置文件\"); 从xml中获取指定ID的对象 方法一[不推荐]: 1ID名类型 id = (ID名类型)ctx.getBean(\"ID名\");//默认输出project类型,强转成id名对应的类型 方法二: 1ctx.getBean(\"ID名\",ID名类型.class); 3.Spring注入1.Set注入1.注入属性的值 注意事项java: 无参构造器的优先级小于set注入的值 public时可以直接User.name,或者用private然后get方法导出来 直接输出对象时输出的是toString方法 注意事项property: XML文件中的property中name与java中setName()有关.set方法的参数名无关 java中的set方法名通常和属性名相同 java文件 123456public class User &#123; public String name; public void set+A变量名(String name) &#123; this.name = name; &#125;&#125; 初始化变量(相当于在set方法传入) 123&lt;Bean id=\"\" class=\"\"&gt; &lt;property name=\"a变量名\" value=\"变量值\"&gt;&lt;/property&gt;&lt;/Bean&gt; 1.2注入非基本值 基础知识 如果某属性的值不是基本值（可以直接在代码中书写的值，例如数值、字符串），而是另一个&lt;bean&gt;时，需要使用ref来确定该属性的值，例如： java 1234public Department department;public Department setDepartment() &#123; return department;&#125; xml 123456&lt;bean id=\"department\" class=\"cn.tedu.spring.department\"&gt; &lt;property name=\"x变量名\" value=\"变量值\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"user\" class=\"cn.tedu.spring.User\"&gt; &lt;property name=\"department\" ref=\"department\" /&gt;&lt;/bean&gt; 2.通过有参构造方法注入属性的值[不常用] 注意事项: 通常情况下都不需要有参构造器,正常的类都需要无参构造器; 如果某个类没有无参数的构造方法，且参数可以用于属性赋值. 同理，如果构造方法的参数的类型不是基本值能表达的，则应该通过ref来注入值！ index是从0开始顺序编号的！ java文件 1234567public class Person &#123; public String name; // Mike public Person(String name) &#123; super(); this.name = name; &#125;&#125; 则在Spring的配置文件中： 1234&lt;bean id=\"person\" class=\"cn.tedu.spring.Person\"&gt; &lt;!-- index：为第几个参数注入值 --&gt; &lt;constructor-arg index=\"0\" value=\"Mike\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3.自动装配非基本值:autowire[不常用] 注意事项: 不建议使用,容易出现错误 自动装配是Spring自动的为属性注入值的做法，也是基于SET注入方式实现的; byName:根据set名称装配: 名称很容易保持一致 byType:根据属性类型装配: 1.没有匹配的对象不会自动配置也不会发生错误; 2.需要保证匹配类型的对象有且仅有1个 xml1 12&lt;bean id=\"user\" class=\"cn.tedu.spring.User\" autowire=\"byName\"&gt;&lt;/bean&gt;&lt;bean id=\"user\" class=\"cn.tedu.spring.department\"&gt;&lt;/bean&gt; xml2 12&lt;bean id=\"user\" class=\"cn.tedu.spring.User\" autowire=\"byType\"&gt;&lt;/bean&gt;&lt;bean id=\"user\" class=\"cn.tedu.spring.department\"&gt;&lt;/bean&gt; 多对象错误 1Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &apos;cn.tedu.spring.UserDao&apos; available: expected single matching bean but found 2: userDao,userDao2 4.注入集合类型1.List/Set[仅了解] 注意事项 set在spring中是:LinkedHashSet; list早spring中是:ArrayList; java 1234public List&lt;String&gt; names;public void setNames(List&lt;String&gt; names) &#123; this.names = names;&#125; xml 123456789&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 2.map[仅了解] 注意事项:LinkedHashMap java 1234public Map&lt;String,Object&gt; session;public void setSession(Map&lt;String,Object&gt; session)&#123; this.session = session;&#125; xml 123456789&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"session\"&gt; &lt;map&gt; &lt;entry key=\"username\" value=\"root\" /&gt; &lt;entry key=\"password\" value=\"ad\" /&gt; &lt;entry key=\"age\" value=\"18\" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 3.数组[仅了解] 注意事项: 数组的配置可以和list混为一谈(set/list/array标签可以互相使用) java 1234public String[] classes;public void setClasses(String[] classes) &#123; this.classes = classes;&#125; xml 12345&lt;list&gt;&lt;!--&lt;array&gt;&lt;set&gt;--&gt; &lt;value&gt;JSD1811&lt;/value&gt; &lt;value&gt;JSD1812&lt;/value&gt; &lt;value&gt;JSD1901&lt;/value&gt;&lt;/list&gt; test 1234SampleBean sampleBean = ac.getBean(\"sampleBean\", SampleBean.class);System.out.println(sampleBean.classes.getClass());//不能直接输出,直接输出输出的是类型System.out.println(Arrays.toString(sampleBean.classes)); 4.properties[掌握] 注意事项: properties存在的原因:相比较于xml可读性更高 spring配置文件使用properties方法: properties 123456url=jdbc:mysql://localhost:3306/db_name?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaidriver=com.mysql.jdbc.Driverusername=rootpassword=rootinitialSize=2maxActive=10 java 1234public Properties dbConfig;public void setDbConfig(Properties dbConfig) &#123; this.dbConfig = dbConfig;&#125; xml 方法1[不推荐]: 12345678&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"dbConfig\"&gt; &lt;props&gt; &lt;prop key=\"driver\"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; ... &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 方法2: &lt;util&gt;相当于bean 还可以用&lt;util&gt;配置其他的集合 1234&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"dbConfig\" ref=\"db\" /&gt;&lt;/bean&gt;&lt;util:properties id=\"db\" location=\"classpath:db.properties\"&gt;&lt;/util:properties&gt; 2.Spring表达式用于获取非基本值 获取非基本值(取代ref) #{bean_id.属性名} 123&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"username\" value=\"#&#123;user.name&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 获取List/Set集合[不推荐] #{bean_id.集合属性名[索引值]} 注意事项 []内的是索引,并不是数组,因此在大多数情况下不建议使用; set不能使用:因为他没有索引(但是Spring中linkedHashSet可以) 123&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"username\" value=\"#&#123;sampleBean.names[1]&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 获取Map集合 1.#{bean_id.map属性名.key} 2.#{bean_id.map属性名[‘key’]} 推荐第一个因为可以少写代码 123&lt;bean id=\"\" class=\"\"&gt; &lt;property name=\"password\" value=\"#&#123;sampleBean.session.password&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 3.注解注入 扫描注解 在Spring加载时执行只会影响启动速度,但是并不会影响使用 1.componet注解: 原理: Spring会扫描包名内所有的class,如果配置了Component注解就会创建对象(包名&gt;=注解所在包) 分类 以下注解的功能是完全等效的,但是应该区分使用: 注解 名称 @Component 通用注解 @Controller 控制类注解 @Service 业务类注解 @Repository 持久层类 配置 xml @Controller注解扫描 1&lt;context:component-scan base-package=\"包名\" /&gt; java 使用默认Bean-id(类名首字母变小写,与之前相同) 123@Componentpublic class 类名&#123;&#125; 自定义Bean-id[不常用] 123@Component(\"id名\")public class 类名&#123;&#125; 2.其他注解[不常用] 多例 1@Scope(\"prototype\")//多例 懒加载 12@Lazy@Lazy(true) 单例[不推荐] 3.2非懒加载(默认) 初始化时立即生效 java 1234567891011public class King &#123; private static King king = new King(); //2.因为要返回同一个对象,因此不能直接返回new对象; private King() &#123;&#125; //1.将构造方法私有化,这样不能在外界new对象 public static King getInstance() &#123; //3.设置成static,可以不创建对象直接调用方法 //4.static执行级别高,因此提前加载进内存,而这里返回的King对象没有加载进去,因此这个King也要设置成static;static一直在内存中,因此取决于使用频率; return king; &#125;&#125; 单例注解 12@Scope(\"singleton\")//默认单例无需添加@Scope//单例 非懒加载 1@Lazy(false) 3.2 懒加载 初始化时不生效,使用时启动(但是初始化一次) java 12345678910111213public class King &#123; private static King king = null; private King() &#123;&#125; public static King getInstance() &#123; if(king==null)&#123;//判断是否需要锁 sychronized(\"java\")&#123;//线程安全问题,两个线程同时进入可能会创建多个对象 if(king==null)&#123;//判断是否创建对象 king = new King(); &#125; &#125; return king; &#125;&#125; 生命周期 在使用这2个注解之前，需要添加Tomcat运行环境，否则这2个注解将无法识别。tomcat负责这两个操作,但是可以在junit中使用 12@PostConstruct 初始化@PreDestroy 结束时 自动装配非基本属性 注意事项: 写在需要自动装配的属性上面,不写在类上面; 先根据byName(set)如果失败再根据byType 方法1: 1234public class abc()&#123; @Component public efgh efg;&#125; 方法2: 注意：@Resource是javax包中的，如果使用该注解，需要项目添加Tomcat环境。 1234public class abc()&#123; @Resource(name=\"efgh\") public efgh efg;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/categories/Spring/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://airbash.cn/tags/Spring/"},{"name":"框架","slug":"框架","permalink":"https://airbash.cn/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Maven","slug":"Apache/Maven","date":"2019-11-01T13:51:58.000Z","updated":"2019-11-06T13:15:59.288Z","comments":true,"path":"2019/11/01/Apache/Maven/","link":"","permalink":"https://airbash.cn/2019/11/01/Apache/Maven/","excerpt":"","text":"1.基础内容1.基础配置 默认配置文件 不相同部分,以局部配置为准 全局配置文件:maven/conf/setting.xml 局部配置文件:user/.m2/setting.xml 默认存储位置:user/.m2/repository 配置本地仓库:修改配置文件 1&lt;localRpository&gt;仓库地址&lt;/localRpository&gt; 2.基础知识1.标准目录结构 目录 内容 src/main/java 核心代码部分 src/main/resources 配置文件部分 src/test/java 测试代码部分 src/test/resouce 测试配置文件 src/main/webapp 页面资源 2.生命周期 生命周期 流程 注意事项 清理生命周期 clean 默认生命周期 compile/test/package/insgall/deploy 执行后面的命令时自动执行前面所有命令 结算生命周期 编译—&gt;测试—&gt;打包—&gt;安装—&gt;发布 2.相关命令 查看当前tomcat版本 1mvn -v[ersion] 删除编译 删除target目录,用于编译环境不同 1mvn clean 编译 编译main 1mvn compile 测试 编译main和test 1mvn test 打包 编译main和test并根据pom.xml中的&lt;packing&gt;配置进行打包 1mvn package 安装 安装到本地仓库,原理先执行mvn package 1mvn install 使用tomcat运行 默认tomcat6不支持java8.0,要先配置tomcat7插件 1mvn tomcat[版本]:run 3.pom.xml配置1.依赖配置1.依赖范围 依赖范围 编译有效 测试有效 运行有效 例子 compile ✔ ✔ ✔ 默认/大多数 test ✔ junit provided ✔ ✔ servlet runtime ✔ ✔ jdbc system ✔ ✔ maven 在依赖上配置,设置为仅在编译时启用 1&lt;scope&gt;provided&lt;/scope&gt; 2.插件配置1.修改jdk版本 方法1 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 方法2 1234567&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt; 2.修改tomcat插件官方版本号 1234567891011121314151617&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;!--2.1或2.2均可--&gt; &lt;configuration&gt; &lt;server&gt;服务器名称&lt;/server&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/访问地址&lt;/path&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4.IDEA1.基础配置 整合maven 设置—&gt;构建/部署—&gt;构建工具—&gt;maven—&gt;maven home—&gt;配置maven根目录 使用本地骨架: 设置—&gt;构建/部署—&gt;构建工具—&gt;maven–&gt;runner—&gt;VM Options—&gt;-DarchetypeCatalog=internal 2.基础操作1.新建maven项目在使用骨架创建maven项目时有的目录需要手动添加,建议不使用骨架,而直接创建原生maven项目,创建成功后会提示build success 标准项目 文件—&gt;new—&gt;项目—&gt;maven—&gt;下一个—&gt;填写相关信息 java骨架 在maven中勾选create from archetype—&gt;选择org.apache.maven.archetypes:maven-archetype-quickstart web骨架 在maven中勾选create from archetype—&gt;选择org.apache.maven.archetypes:maven-archetype-webapp 2.设置目录为web目录设置后可以新建web相关的文件 文件—&gt;项目结构—&gt;模块—&gt;选择要编辑的项目中的web(没有的话右击添加web)—&gt;将目录添加进去 3.没有新建servlet文件文件—&gt;项目结构—&gt;模块—&gt;选择要编辑的项","categories":[{"name":"Apache","slug":"Apache","permalink":"https://airbash.cn/categories/Apache/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://airbash.cn/tags/Maven/"},{"name":"版本管理","slug":"版本管理","permalink":"https://airbash.cn/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}]},{"title":"SVN","slug":"版本管理/SVN","date":"2019-11-01T13:33:12.000Z","updated":"2019-11-06T03:36:22.457Z","comments":true,"path":"2019/11/01/版本管理/SVN/","link":"","permalink":"https://airbash.cn/2019/11/01/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/SVN/","excerpt":"","text":"二.SVN1.安装1.安装服务端建议安装visualSVN server图形化操作软件,或者官网推荐软件subvison 2.安装客户端建议安装TortoiseSVN图形化操作软件和其对应的汉化包 2.Eclipse1.相关配置1.安装svn下载subclise插件; 2.断开svn连接​ 断开连接:右击项目&gt;&gt;&gt;team&gt;&gt;&gt;断开连接&gt;&gt;&gt;勾选删除云数据(不作为svn) 3.删除已保存资源库位置:​ svn资源库&gt;&gt;&gt;删除多余位置 4.将svn插件设置为英文 打开eclipse所在目录\\configuration\\config.ini文件 增加英文配置: 12# Set Subversion English Versionosgi.nl=en_US 5.查看svn记录打开svn记录视图 2.SVN操作1.提交项目 右击项目&gt;&gt;&gt;team&gt;&gt;&gt;share&gt;&gt;&gt;输入svn仓库地址&gt;&gt;&gt;在不输入密码的情况下要点击finsh4-5次 右击项目&gt;&gt;&gt;team&gt;&gt;&gt;commit 2.下载项目 打开svn视图:windows&gt;&gt;&gt;show view&gt;&gt;&gt;other&gt;&gt;&gt;svn资源库 添加资源库:右击svn资源库(或者点击视图右上角图标)&gt;&gt;&gt;添加新的资源库&gt;&gt;&gt;填写url check out:右击资源库&gt;&gt;&gt;检出为..&gt;&gt;&gt;作为工作空间中的项目检出[&gt;&gt;&gt;修改项目名称&gt;&gt;&gt;选择保存到的位置] 手动导入该项目","categories":[{"name":"版本管理","slug":"版本管理","permalink":"https://airbash.cn/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://airbash.cn/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"SVN","slug":"SVN","permalink":"https://airbash.cn/tags/SVN/"}]},{"title":"Git","slug":"版本管理/Git","date":"2019-11-01T12:24:04.000Z","updated":"2019-11-06T03:36:22.456Z","comments":true,"path":"2019/11/01/版本管理/Git/","link":"","permalink":"https://airbash.cn/2019/11/01/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git/","excerpt":"","text":"1.基础介绍1.详情 基础知识: 分布式管理系统,与之相对应的是svn集中式管理系统 汉化gui教程; 环境变量: 默认自动修改 2.快捷键 快捷键 名称 ctrl+l 清屏 3.版本分支流程 相关信息 英文名 中文名 作用(流程见流程图) master 主干分支 develop 开发分支 hotfix bug修理分支 release 发行前测试分支 流程图 4.新建项目流程 新建目录(库),在目录内新建文件,右击git输入git init命令 打开github—project创建库和项目 打开项目复制项目网页上的库地址(ssh或https) 建立github和本地库的联系 添加到缓存区—&gt;本地仓库–&gt;-远程 2.命令1.基础配置 基础配置: 每次git提交时都会引用这两条信息,以说明是谁提交了更新,并永久纳入历史记录 下列是全局配置,当版本库没有配置时启用 –global:全局配置,不写就是配置当前版本库 设置个人邮箱 1git config [--global] user.email &quot;294379349@qq.com&quot; 设置个人用户名 1git config [--global] user.name &quot;zsp&quot; 设置默认文本编辑器 subl 配置了sublime 可以使用subls 1git config [--goble] core.editor 名称 配置完成后,自动在/用户目录下生成/.gitconfig文件,里面保存着1-3设置的内容,也可以直接修改该文件 2.SSH秘钥登录 生成秘钥 默认保存在 /用户名/.ssh中 1ssh-keygen -t rsa -C 注释 打开github—settings,添加ssh秘钥,将.ssh中的公钥写入(注意删除末尾空格) 验证连通性 成功的话会在.ssh目录下生成known_hosts文件,并提示access 1ssh -T git@github.com 3.仓库命令 创建仓库 在工作目录中执行,成功后会生成.git文件 1git init [目录] 将本地文件添加到暂存区 .:所有文件;*.java:java文件 1git add 文件名 将缓存区文件推送到本地仓库 1git commit [-m &quot;注释&quot;] 建立远程库和本地库的联系 1git remote add origin 项目地址 将本地仓库推送到远程仓库 第一次推送 1git push -u origin master 第二次推送 1git push origin 版本 将远程仓库下载到本地仓库 直接clone就不需要init和remote命令,因为该命令相当于创建并建立关系 第一次下载 111.230.13.216 1git clone 地址 普通下载 1git pull 4.排除文件 范围 配置文件 优缺点 全局 位置自定义/,gitignore 操作简单,仅个人可用 局部 项目/.git/.gitignore 所有人可用 局部本地 项目/.git/info/exclude/.gitignore 仅本地单个项目可用 指定全局配置文件 1git config --global core.excludesfile /指定目录/.gitignore 从版本控制中取消并add 12git rm -r --cached .git add . 组件 作用 -r 递归删除(与linux相似) –cached 不删除文件,仅从索引中删除 3.Eclipse1.安装配置 下载egit插件 打开windows—Preferences 选择Team—Git Git—Default repository folder:配置默认clone目录,这里设置为工作目录 Configuration—User Settings—Location:配置默认git配置文件.gitconfig(可以在此处修改email和name) 配置SSH私钥目录:选择General—Network Connections—SSH2—General—SSH2 home: 2.新建库 git init 复制项目到指定库中:右击项目Team—ShareProject—Create—选择要生成到的目录上 将项目变成库:右击项目Team—ShareProject,勾选Use or create repository in parent folder of project,点击Create Repository git add . 右击项目Team—add to index git commit 右击项目Team—commit—弹出窗口—书写注释—commit 右击项目Team—commit—弹出窗口—书写注释—commit and push(会让你执行以下操作) git remote add origin 项目地址&amp;git push 右击项目Team—Remote—push—URL:地址—source ref:设置分支类型—点击add Spec—next 3.下载库 new—other—git—clone 右击项目—Team–pull 4.冲突解决 查看冲突: 右击项目—Team—synchonrized 处理冲突: 工具处理:右击项目—Tream—marge Tool 直接处理: 本地冲突文件:git add—git commit—git push移动到本地仓库 远程冲突文件:git pull覆盖本地文件 比较二者的区别 5.版本分支 新建分支 右击项目—&gt;Team—&gt;Switch to—&gt;new Branch—&gt;弹出窗口 Select:选择要克隆的分支—&gt;Branch name:设置分支名称 合并分支","categories":[{"name":"版本管理","slug":"版本管理","permalink":"https://airbash.cn/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://airbash.cn/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"Git","slug":"Git","permalink":"https://airbash.cn/tags/Git/"}]},{"title":"BigDecimal","slug":"JAVA/BigDecimal","date":"2019-11-01T12:16:38.000Z","updated":"2019-11-06T03:36:22.436Z","comments":true,"path":"2019/11/01/JAVA/BigDecimal/","link":"","permalink":"https://airbash.cn/2019/11/01/JAVA/BigDecimal/","excerpt":"","text":"案例: double和float类型会发生精度丢失 1syso(0.01+0.01); 相关方法 新建对象 基于String的构造器 1BigDecimal d1 = new BigDecimal(\"0.01\"); 静态ValueOf方法 1BigDecimal d2 = BigDecimal.ValueOf(\"0.01\"); 计算 加 1BigDecimal d = d1.add(d2); 减 1BigDecimal d = d1.subtract(d2); 乘 1BigDecimal d = d1.multiply(d2); 除 小数点都输出[不推荐/不常用]默认四舍五入 1BigDecimal d = d1.divide(d2); 固定小数点到第n位:默认四舍五入 1BigDecimal d = d1.divide(d2,n); 四舍五入方法 1BigDecimal d = d1.divide(d2,n,舍入模式); 舍入模式 BigDecimal[淘汰不推荐] RoundingMode 作用 个人理解 ROUND_UP UP 始终对非零舍弃部分前面的数字加1 ROUND_DOWN DOWN 从不对舍弃部分前面的数字加1，即截短 ROUND_CEILING CEILING 正数:ROUND_UP/负数:ROUND_DOWN 利益最大化 ROUND_FLOOR FLOOR 负数:ROUND_UP/正数:ROUND_DOWN ROUND_HALF_UP HALF_UP 四舍五入 ROUND_HALF_DOWN HALF_DOWN 五舍六入 ROUND_HALF_EVEN HALF_EVEN 1.5&gt;2 1.25&gt;1.5 美国方法 ROUND_UNNECESSARY UNNECESSARY","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"}]},{"title":"反射相关知识","slug":"JAVA/反射","date":"2019-11-01T12:12:16.000Z","updated":"2019-11-06T03:36:22.440Z","comments":true,"path":"2019/11/01/JAVA/反射/","link":"","permalink":"https://airbash.cn/2019/11/01/JAVA/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"1.获取class对象​ eclipse按alt+/不会补全新建对象的变量名,需要手动补全; 类的class属性[推荐] 代码更安全性能更好 1class clazz = String.class; Class的静态方法forName 仅当给出完整类名(包含包名)时使用,因为如果类包名错误会报错; 12345try&#123; Class forName = Class.forName(\"java.lang.String\");&#125;catch(ClassNotFoundException e)&#123; ...&#125; Object类里的getClass()方法 12String str= &quot;x&quot;;Class clazz = str.getClass(); 2.新建对象 java不推荐使用 12345try&#123; Object object = clazz.newInstance([\"参数1\",\"参数2\",..]); &#125;catch()&#123; ...&#125; java推荐使用[推荐] 12345try&#123; Object object = clazz.getDeclaredConstructor().newInstance([\"参数1\",\"参数2\",...]);&#125;catch()&#123; ...&#125; 3.获取class信息[了解] 获取修饰符[了解] 返回值是修饰符值相加 1int x = clazz.getModifiedrs(); 列表 修饰符 值 ABSTRACT 1024 FINAL 16 INTERFACE 512 NATIVE 256 PRIVATE 2 PROTECTED 4 PUBLIC 1 STATIC 8 STRICT 2048 SYNCHRONIZED 32 TRANSIENT 128 VOLATILE 64 获取类名 获取完整包类名 1String name = clazz.getName(); 获取类名 1String name = clazz.getSimpleName(); 获取包名 1Stirng name = clazz.getPackName(); 获取超类(父类) 1Class sclazz = clazz.getSuper().getName(); 4.获取class属性​ getDeclarredFields/Methods/Constructors是获取私有数据,不加不能获取私有数据 获取属性(变量)数组 1Field[] x= clazz.getFields(); 已知属性名获取[不常用] 1Field x =clazz.getFields(\"属性名\"); 获取方法数组 1Method[] y = clazz.getDeclaredMethods(); 已知方法名和类型获取[不常用] 1Method y = clazz.getDeclaredMethods(\"方法名\",参数类型1.class,参数类型2.class); 获取构造方法数组 1Constructors[] z = clazz.getDeclaredConstructors()[.getName]; 已知有参构造器获取[不常用] 1Constructors z = clazz.getDeclaredMethods(参数类型1.class,参数类型2.class); 5.获取修改属性信息 获取名称 1String name = x/y/z.getName(); 获取修饰符 1int a = x/y/z.getModifiders(); 设置私有属性可被修改/访问 1x/y/z.setAccessible(true); 获取属性类型 1Class type= x.getType()[.getName()]; 属性名 获取 1Object oject = [(类型)]x.get(要获取的对象); 赋值 1x.set(要被赋值的对象,\"值\"); 获取参数列表类型 1Class[] Parameter = y/z.getParameterTypes(); 获取返回值类型 1Class return = y/z.getReturnType(); 获取抛出异常的类型 1Class exception = y/z.getExceptionType(); 执行方法 1x.invoke(要被执行的方法,\"参数1\",\"参数2\"); 6.事例​ 模仿springIOC功能 Father.java 1234private String name;private Integer age;private String sex;get/set/构造方法/toString; MySpring.java 12345678910111213141516171819202122232425262728293031323334public Object getBean(String className) &#123; Object object = null; Scanner input = new Scanner(System.in); System.out.println(\"请给\"+className+\"类的对象赋值\"); try &#123; //1.getBean Class&lt;?&gt; clazz = Class.forName(className); object = clazz.newInstance(); //2.依赖注入:通过成员变量生成set方法 Field[] fields = clazz.getDeclaredFields(); for(Field field :fields) &#123; //(1.)拼接成员变量变成set方法 String fieldName = field.getName(); String upperCase = fieldName.substring(0, 1).toUpperCase(); String substring = fieldName.substring(1); StringBuilder setMethodName = new StringBuilder(\"set\"); setMethodName.append(upperCase); setMethodName.append(substring); //(2.)通过拼接到的set方法名获取set方法对象 Class&lt;?&gt; Fieldtype = field.getType(); Method method = clazz.getDeclaredMethod(setMethodName.toString(), Fieldtype); method.setAccessible(true); System.out.println(\"请给\"+setMethodName+\"赋值\"); String value = input.nextLine(); //(3.)采用newInteger(String)的方式转换格式 Constructor&lt;?&gt; fieldConstructor = Fieldtype.getDeclaredConstructor(String.class);//获取参数类的(string)构造方法 Object value2 = fieldConstructor.newInstance(value);//通过构造方法新建对象 method.invoke(object, value2); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return object;&#125; test.java 12345public static void main(String[] args) &#123; MySpring spring = new MySpring(); Father father = (Father)spring.getBean(\"Other.反射.untity.Father\"); System.out.println(father);&#125; 2.commons","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"},{"name":"反射","slug":"反射","permalink":"https://airbash.cn/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"JavaAPI","slug":"JAVA/JavaAPI","date":"2019-11-01T12:08:13.000Z","updated":"2019-11-06T03:36:22.437Z","comments":true,"path":"2019/11/01/JAVA/JavaAPI/","link":"","permalink":"https://airbash.cn/2019/11/01/JAVA/JavaAPI/","excerpt":"","text":"1.String1.新建对象 常量池(方法区) 1String str=\"x\"; 新创建 1Stirng str=new String(\"x\"); 区别 常量池创建是在现有堆中查找是否有相同的内容,如果有指向同一数据;新创建中则忽略 先在常量池中创建再在新堆中创建,指向的内容不相等;先在新堆中创建,再在常量池中查找(此时的常量池就是刚创建的新堆)指向的内容相同; 123String str1=\"x\";String str2=new String(\"x\");syso(str1==str2);//输出flase; 123String str1=new String(\"x\");String str2=\"x\";syso(str1==str2);//输出true; 常量池中创建是在一个堆中,而新堆创建是在两个堆中 123String str1=\"x\";String str2=\"x\";syso(str1==str2);//输出true; 123String str1=new String(\"x\");String str2=new String(\"x\");syso(str1==str2);//输出flase 2.相关方法 检索str的位置 没有检索到返回-1; 检索第一次出现str的位置: 1int x = indexOf(str); 检索从n开始出现str的位置: 1int x = indexOf(str,n); 检索最后一次出现str的位置; 1int x = LastIndexOf(str); 获取指定位置字符串 获取从n1到n2的字符串 1String str = str.substring(n1,n2); 获取从n开始到结尾的字符串 1String str = str.substring(n); 获取位置n上的字符串 1String str = str.charAt(); 去除字符串前后的空字符串 1String str = str.trim(); 查询是否存在 以str2开头的字符串 1boolean b = str.startsWith(str2); 以str2结尾的字符串 1boolean b = str.endsWidth(str2); 正则表达式方法 是否存在正则表达式相配数据 1boolean b = str.matches(“正则表达式”);//true:相同 将一个字符串拆分成字符串数组 1String[] b = str.split(正则表达式); 将字符串的一部分用于替换 1String b = str.replaceAll(正则表达式，被替换); 3.StringBuffer/Builder String是不可变的(被final修饰); 12String str=\"1\";str=str+\"2\"; 流程:JVM创建第一个str对象并赋值”1”,创建第二个str并赋值”12”,GC垃圾回收机制处理掉第一个str StirngBuffer是可变的 StringBuffer是线程安全的,StringBuilder是线程不安全的;StringBuilder是性能最好的; 2.集合1.基础知识 数组和集合的区别 数组长度不可变,集合的长度可变; 数组无法保存具有映射关系的数据; 数组可以保存基本数据和对象,集合只能保存对象(对象的引用变量); 所属包: java.util(工具类,java5以后再java.util.concurrent包下提供线程安全集合类) 包含类: Collection:接口类,集合框架的根接口 Map:接口类,集合框架的根接口 2.Collection集合1.基础知识1.Collection 基础知识: collectoion是顶级父类接口;Set/List是子接口 Collection接口派生的集合默认长度为0 关系图: 2.List和Set的区别 List集合是序列(有序)的,允许元素重复; java.util.ArrayList: 内部由数组实现,查询效率好; 修改必须新建重新赋值; java.util.LinkedList: 内部由链表实现,增删效率好,尤其是首尾增删; 查询慢必须一个一个查询,修改快,只需要插入即可 Set集合是散列(无序)的,不允许元素重复(若重复则只显示一个): 相同元素的标准:2个对象的equals()对比结果为true且hashCode()返回值相同 如果使用的实现类是TreeSet，还要求集合中的元素实现Comparable接口。 3.Collection共有方法 新建对象: set/array亦可 1Collection&lt;Integer&gt; collection = new Collection&lt;Integer&gt;(); 添加: 添加元素: 1collection.add(1); 将集合2的数据复制到集合1中: 如果collection是list集合重复的数据只显示一份,set集合可以重复 1collection.addAll(collection2); 删除: 删除元素: 1collection.remove(1); 删除两个集合中相同的元素 1collection.removeAll(collection2); 集合的大小 1int size = collection.size(); 空集 清空为空集 1collection.clear(); 检测是否为空集 1boolean is = collection.isEmpty(); 更改元素:将位置1的数值更改为2;仅适用于List 1collection.set(1,2); 包含 判断集合中是否有1; 1boolean contain = collection.contain(1): 判断C1中是否包含C2中的所有元素 1boolean contains = collection.containAll(c2); 2.遍历集合1.Iterator1.Iterator 属性: 位于顶级父类Collection中的方法; 遍历数组时里面不能使用集合的方法(多数情况下会报错) 执行读写删读写删操作； 步骤 创建集合 1Collection c = new ArrayList(); 返回一个迭代器,返回Iterator类型的对象 1Iterator it = c.iterator(); 遍历 遍历时别修改集合的值会报错 1234while(it.hasNext())&#123; //判断是否还有下一个元素可以遍历 String o =(String)it.next();//将接收到的内容强制转换为String类型 it.remove(); //删除调用的集合 (此处不能使用集合的方法)&#125; 2.匿名内部类 原理 Iterable接口新增一个forEach()默认方法,Iterable接口是Collection接口的父接口 遍历 1it.forEachRamaining(obj -&gt; System.out.println(\"迭代集合元素:\"+obj)); 2.增强for1.增强for​ 新循环是编译器认可的，编译器编译或将新循环遍历数组为普通for； 数组： 12345678for(int i = 0; i&lt;arr.length;i++) &#123; String str = arr[i]; System.out.println(str);&#125;for(String str : arr) &#123; System.out.println(str);&#125;Arrys.toString(arr); 集合： 新循环遍历集合会被编译器改为迭代器遍历（不需要返回一个迭代器了） 12345678for(Object o : c) &#123; String str = (String)o; System.out.println(str);&#125;Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();//指定类型for(String str : c) &#123; System.out.println(str);&#125; 2.匿名内部类表达式 1books.forEach(obj -&gt; System.out.println(\"迭代集合元素:\"+obj)); 3.Set1.HashSet当向HashSet集合中添加可变对象时,如果修改集合中对象,有可能导致对象与集合中的其他对象相同,从而导致HashSet无法准确访问该对象 添加规则 判定元素是否重复标准 比较两个元素的hashCode()方法返回的hashCode值,如果不相等则为合格; 两个元素进行equals()比较是否为同一对象,如果结果为flase则为合格; 以上两个只有有一个合格就可以添加成功,; 单个合格的缺点 eualas合格,hashcode不合格:就会导致两个元素被分配到不同的hash值地址上,但是元素是相同的,与set规则不相符(元素不可以重复); hashcode合格,equals不合格:就会导致两个元素被分配到相同的hash值地址上,用链表的形式保存,因为查找元素是靠hash值,这样会导致查询速度变慢; 重写hashCode和equals规则 如果重写euals方法时就要重写hashCode;hashCode和equals都为合格或都为不合格 重写HashSet HashSet计算公式: 通常只使用引用类型 计算Haash值 方法1: 123public int code()&#123; return f1.hashCode()*17+f2.hashCode()*31+...;&#125; 方法2: 1234567public int code()&#123; int result = 17; result = result * 31 + ((Book == null) ? 0 : Book.hashCode()); result = result * 31 + ((Name == null) ? 0 : Name.hashCode()); ... return result;&#125; 方法3: eclipse自动生成 2.linkedHashSet HashSet的子类,拥有HashSet的功能; 存储: 排序方式:按照集合元素的添加顺序; 存储位置:按照hash值存储 通过链表维护集合元素的顺序,是一个有序的set,不可重复 add时性能略低与HashSet,遍历时性能略高于HashSet 3.TreeSet 基础知识: TreeSet是SortSet接口的实现类;SortSet是Set的子接口; 存储: 排序方式:按照集合内元素的大小排序; 存储位置:按照红黑树数据结构; 相关方法 返回第一个元素 1treeSet.firset(); 返回最后一个元素 1treeSet.last(); 元素的前一个元素 1treeSet.last(); 元素的后一个元素 1treeSet.last(); 返回t1和t2之间元素(以集合的形式) 1treeSet set = subSet(t1,t2); 返回小于t的所有元素(以集合的形式) 1treeSet set = headSet(t); 返回大于t的所有元素(以集合的形式) 1treeSet set = tailSet(t); 排序方式: 基础知识: 要添加的元素最好是同一类型,否则会报错; 要添加的元素的实体类一定要有排序规则; 如果修改添加完的数据会导致大小顺序发生改变不会刷新,并且重复和修改的数据不能被删除 自然排序: 排序原理: 调用元素的compareTo(Object obj)方法比较元素之间的大小,然后将元素升序排序; 实现方法: 实体类实现Comparable接口,重写compareTo(Object obj)方法,定义排序规则; 排序规则: A1.compareTo(A2)返回值&gt;0代表A1&gt;A2; A1.compareTo(A2)返回值&lt;0代表A1&lt;A2; A1.compareTo(A2)返回值=0代表A1=A2; 排序公式: 12345678class student() implements Comparable&#123; private String name; private Integer id; public int compareTo(Studnet student)&#123; return id-student.id; return id-student.id&gt;0?1:id-student.id&lt;0?-1:0; &#125;&#125; 定制排序: 排序原理: ThreSet的自然排序是根据集合元素的大小,TreeSet将他们以升序排列; 在新建TreeSet对象时,传入一个实现Comparator接口并重写compare(T1,T2)方法的对象,在compare中重新定义排序规则 排序公式 123new TreeSet((School s1,School s2)-&gt;&#123; return s1.getId()-s2.getId();&#125;); 4.EnumSet枚举类 4.List1.基础知识 属性: 有序列表HashSet不继承List; 实现类: 一般使用ArrayList 方法(不包括collection) List list = new ArrayList();//括号内可以传入一整个集合 将位置2添加新元素12 1list.add(2,”2”); 将位置2删除 1list.remove(2); 将位置2更新为3 1list.set(2,”3”); 获取位置2 1list.get(2); 生成list的[3,8)的子集subList 1List.subList=list.subList(3,8); 将生成的子集删除(子集修改父集也会被删除) 1list.subList(3,8)clear(); 2.转换 集合转换数组 toArray是Collection的方法,他的子类也可以使用; 12Collection c = new ArrayList();String[] array = c.toArray(new String[c.size()]); c.size的长度没有达到数组该有的长度会补齐 数组转换集合 Arrays提供了一个静态方法asList,将数组转换为List集合 123String[] arr = &#123;\"one\",\"two\",\"three\",\"four\"&#125;;List list = Arrays.asList(arr);Arrays.toString(arr); 4.栈结构 队列:先进先出;//后进前出 所属类: java.util.queue 父类: Collection 实现类: LinkedList 方法 12345Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();tring str = queue.poll();//将第一个输出(输出后在集合中消失)依次输出:用i--;因为只有定义为初始值才不会改变;str = queue.peek();//将第一个输出queue.offer(\"a\");//在后面添加一个数 双端队列:两端都可以输入输出; 所属类: java.util.Deque 父类: queue 实现类: LinkedList 方法: 1234deque.offerFirst();deque.offerLast();deque.pollFirst();deque.polLast(); 栈结构:再同 一端进入输出可用于前进后退功能 12queue.push();queue.poll(); 3.Map集合 新建map 1Map map&lt;String,String&gt; = new Map&lt;String,String&gt;(); 返回所有key 1Set&lt;String&gt; keys = map.keySet(); 返回所有value 1Set&lt;String&gt; values = map.keyValue(); 4.Collections所属类: java.util.Collections (Collection的集合工具类); 1.封装线程安全集合 Collection 12Conllection collection = new ArrayList();collection = Collections.synchronizedList(list); List 12List list = new ArrayList();list = Collections.synchronizedList(list); Set 12Set set = new HashSet(list);set = Collections.synchronizedSet(set); SortedMap/Tree SortedSet/Tree 2.List集合排序 自然排序 升序操作 1Collections.sort(list); 自定义排序 Comparator:自然排序重写 1Collections.sort(list,Comparator); 乱序 1collections.shuffle(list); 翻转排序 1collecions.reverse(list); 3.创建不可变集合3.线程1.注意事项main方法也是一个线程 2.创建线程​ 建议使用Runnable或Callable 由于java里一个类只能继承一个父类,所以Thread只能继承一个父类,而runnable和callable可以继承多个父类 runable和callable可以实现代码的分离,面向对象 runable和callable代码复杂,获取线程对象要用Thread.currentThread()方法,而thread可以直接对象点; 1.继承Thread 新建线程:新建类继承Throw,重写run方法 12345public class Test() extends Throw()&#123; public void run()&#123; 线程需要执行的内容; &#125;&#125; 创建线程: 1Test test = new Test(); 启动线程:创建一个新的栈,而不是创建栈帧 1test.start(); 2.实现Runnable 新建线程:新建线程类,实现Runnable接口,重写run方法 12345public class Test implements Runnable&#123; public void run()&#123; 线程内容; &#125;&#125; 创建线程对象 1Test test = new Test(); 新建线程 1Thread thread = new Thread(thread[,\"线程名\"]); 执行线程 1thread.start(); 3.使用Callable和Future 新建线程:新建范方法线程类,实现Callable类,重写call方法可以抛出异常而不需要必须在县城里处理 12345public class Test implements Callable&lt;call方法返回值&gt;&#123; public Integer call() throws Exception&#123; 线程内容; &#125;&#125; 新建线程对象 12Test test = new Test();FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(test); 执行线程 1Thread thread = new Thread(result); 执行线程 1therad.start(); 返回值:get()会阻塞到结束时执行 123try&#123; Integer sum = result.get();&#125;catch()&#123;&#125; 4.其他方法创建1.匿名内部类 Thread 12345Thread thread = new Thread()&#123; public void run()&#123; &#125;&#125;thread.start(); Runnable 12345Thread thread = new Runnable()&#123; public void run()&#123; &#125;&#125;new Thread(thread.start()); 2.Lambda表达式当新建的线程类中只有一个方法时就可以使用Lambda表达式 5.Threa对象 获取线程对象(静态) run方法内 只适用于实现Runnable或Callable的接口的run方法内执行 不能使用this,this指的是线程类这一个对象,而静态方法获取的是不同的三个对象 1Thread thread = Thread.currentThread(); 线程外获取对象 12Test test = new Test();Thread thread = new Thread(test); 获取线程名 1String name = thread.getName(); 获取线程id 1Int id = thread.getId() 获取线程优先级[见下文] 1thread.getPriority(); 检查是否处于活动状态[见下文] 线程处于:就绪/运行/阻塞返回true,处于新建/结束返回flase; 1thread.isAlive(); 检查是否为守护线程[见下文] 1thread.isDaemon(); 检查是否被中断 1thread.isInterrupted(); 3.生命周期 图表 状态 线程 新建 使用new关键字创建线程后 就绪 线程对象调用start()方法后 运行 获得cpu资源,执行run方法体后 死亡 run()结束/错误/执行stop() 图示 线程从阻塞状态只能进入就绪状态 注意事项 主线程和子线程: 主线程和子线程有相同的地位,子线程不收主线程的影响,主线程结束后子线程可以继续执行; start() 对新线程两次调用start()或者对死亡的线程调用start()都会抛出异常illegalThreadStateException 调用run()方法以后不能再次调用start()方法会抛出异常 4.控制线程 新建线程: Thread/Runnable/Callable 12Test test = new Test();Thread thread = new Thread(test); 1.join因为阻塞后会处于就绪,因此.start()可以解除join 在therad2线程中调用thread.join()方法,therad2会被一直阻塞,直到therad执行完毕 1thread.join(); 在therad2线程中调用thread.join(n毫秒)方法,therad2会被一直阻塞n毫秒 1thread.join(n); 2.后台线程(守护线程) 注意事项: 当前台线程全部执行完毕,守护线程也随之结束,jvm的gc就是守护线程, 线程处于:就绪/运行/阻塞返回true,处于:新建/结束返回flase; 前台线程创建的默认是前台线程,后台线程创建的线程默认是后台线程; 设置为后台线程 必须在thread.start()之前执行,否则返回illegalThreadStateException 1thread.setDaemon(true); 获取当前线程状态 1boolean flag= thread.getDaemon(); 3.sleep(线程休眠)可能发生死锁,尽量少使用,run方法内执行 让thread线程休眠 1Thread.sleep(); 让thread休眠n毫秒(收系统精度影响) 1Thread.sleep(n); 4.yield(线程让步)移植性低,不建议使用,建议使用sleep 会将线程强制转换到就绪状态,而不是阻塞,在执行后会暂停并给大于等于自身优先级的线程(包括)执行机会, 1Thread.yield(); 5.设置优先级每个线程默认的优先级都与创建它的父线程优先级相同; 优先级级别 范围从1-10,但是由于要受操作系统的影响,所以应该尽量使用常量优先级 常量优先级 常量 级别 Thread.MAX_PRIORITY 10 Thread.MIN_PRIORITY 1 Thread.NORM_PRIORITY 5(main) 获取优先级 1int x = thread.getPriority(); 设置优先级 1thread.setPriority(优先级); 5.线程同步1.并发产生的原因12345int total2=2000if(total&gt;total2)&#123; //1 syso(\"取钱成功:\"); total2=total2-1500; //2&#125; 如果线程1在经过1时正好堵塞,线程2在此期间执行完毕,这时线程1再执行完毕则出现错误;也就是说有同时执行1的可能 2.同步代码块参数是同步监视器:当一个线程使用obj时阻止其他线程使用,直到代码块执行完毕 同步监视器:obj,需要竞争的对象资源 同步代码块:需要执行的操作 123synchronized(obj)&#123; //加锁 同步代码块 //修改&#125; //释放锁 3.同步方法在自定义类中加同步方法:被synchronized修饰的方法,默认同步监视器是this就是当前对象; 123public synchronized void XXX()&#123; 同步代码块&#125; 4.同步锁在实现方法中书写同步锁:java8新功能,ReentrantLook可以被多次加锁 步骤 新建ReentrantLook(可重入锁) 1private final Look look = new ReentranLook(); 代码开头加锁 1look.look(); finally中解锁 1look.ulook(); 案例 123456private final ReentrantLock lock = new ReentrantLook(); public void x()&#123; look.look(); try&#123;代码&#125; finally&#123;look.unlook()&#125;;&#125; 5.死锁在系统中出现多个同步监视器的情况下容易死锁; 6.同步监视器何时释放和锁定 释放同步监视器的锁定 同步方法或代码块执行结束 遇到break/return提前结束同步方法或代码块 出现未处理的error或Exption导致同步放那个发或代码块结束 执行了同步监视器对象的wait()方法,使当前线程暂停会释放监视器 不释放同步监视器的锁定(容易死锁) Thread.sleep()/Thread.yield() suspend()将线程挂起 6.线程通信1.传统通信 相关方法: Object的三种方法,仅适用于同步块和同步方法 当前线程等待,知道调用notify()或notifyAll(); 1wait(); 唤醒在此同步监视器上等待的单个线程 1notify(); 唤醒在此同步监视器上等待的所有线程 1notifyAll(); 案例: 当程序进入draw2()存钱方法后,如果flag为true,表示账户中有人正在取钱,程序调用wait()方法阻塞存钱方法;反之如果flag为flase表示账户中没有人正在存钱此时执行存钱操作,最后将flag设置为true,并唤醒存钱期间被阻塞的取钱操作,被唤醒的取钱线程会执行取钱操作最后将flag设置为false,并唤醒取钱期间被阻塞的存钱操作;注意事项:在类中设置flag默认为flase,所以直接执行取钱操作就会有问题; 123456789101112131415161718192021222324252627282930public class A&#123; private String ANo;//账户编号 private double price;//账户余额 private boolean flag = false;//true:有人正在取钱|false:有人正在存钱 get/set/toString(price只写get处于安全考虑) public synchronized void draw(double price2)&#123; try&#123; if(!=flag)&#123; wait(); &#125;else&#123; price = price - price2; flag = false; notifyAll();//唤醒其他线程; &#125; &#125; &#125; public synchronized void draw2(double price2)&#123; try&#123; if(flag)&#123; wait(); &#125;else&#123; price = price + price2; flag = true; notifyAll();//唤醒其他线程; &#125; &#125; &#125;&#125; 2.Condition通信 步骤 仅适用于同步锁 新建look对象 1private final Look look = new ReentrantLook(); 获得Condition对象 1private final Condition conditon = Conlook.newCCondition(); await(); signal(); signalAll(); 案例 1234567891011121314151617181920212223242526272829303132public class A&#123; private String ANo;//账户编号 private double price;//账户余额 private boolean flag = false;//true:有人正在取钱|false:有人正在存钱 get/set/toString(price只写get处于安全考虑) public void draw(double price2)&#123; look.look(); try&#123; if(!=flag)&#123; wait(); &#125;else&#123; price = price - price2; flag = false; notifyAll();//唤醒其他线程; &#125; &#125;catch()&#123; &#125;finally&#123; look.ulook; &#125; &#125; public void draw2(double price2)&#123; try&#123; if(flag)&#123; wait(); &#125;else&#123; price = price + price2; flag = true; notifyAll();//唤醒其他线程; &#125; &#125; &#125;&#125; 3.阻塞队列[待学]7.线程组和未处理的异常8.线程池1.相关线程池 线程池 作用 注意事项 newFixedThreadPool() 固定数量线程池 newCachedThreadPool() 缓存线程池 newScheduledThreadPool() 周期性线程池 newSingleThreadExecutor() 单线程线程池 2.创建线程池 创建线程池 1ExcutorService pool = Executors.线程池(); 创建线程池 1 向线程池中提交线程(可提交多个) 1pool.submit(target); 关闭线程池 1pool.shutdown(); 9.线程相关类1.ThreadLocal2.包装线程3.线程安全 集合:详情请见Collections中 Random—–ThreadLocalRandom 4.IO操作1.File类1.相关方法 新建对象,而不是文件(file为地址); 自定义地址创建 1File file = new File(\"/demo\"); 在指定目录下创建[只在大量创建子目录时使用] 1File file = new File(mkdir,\"demo\"); 显示File信息 地址 12file;//方法1:直接输出file对象,不是String类型String path = file.getPath();//方法2 文件/目录名 1String name = file.getName(); 绝对地址=绝对名字 12File AbsoluteFile = file.getAbsoluteFile();//方法1String absolutePath = file.getAbsolutePath();//方法2:absolluteFile().tostring(); 检测 是否是目录或文件 1boolean exists = file.exists(); 是否是目录 1boolean directory = file.isDirectory(); 是否是目录 1boolean file = file.isFile(); 创建/删除 创建目录 1mkdir.mkdir();//(父级目录必须存在,例如\"A//b//,则A必须存在\") 创建多级目录 1mkdirs.mkdirs();//(腹肌目录不存在会一起创建) 创建文件(需要处理IOException) 文件可能被占用 1file.createNewMkdir(); 删除文件/目录 不能删除非空目录,见案例详述 1file/mkdir.delete(); 其他 文件/目录大小 1long length = file/mkdie.length(); 返回目录下的所有文件和目录地址 1File[] list = mkdir.listFiles(); 返回目录下的所有文件和目录名 1String[] list = mkdir.list(); 转换为nio的path对象 1Path path = file.toPath(); 临时目录 前缀最少3位数,并且是生成以前缀为开头的随机文件名 新建临时文件夹 1File.createTempFile(\"前缀\",\"后缀\"); 在指定目录下创建临时文件夹 1File.createTempFile(\"前缀\",\"后缀\",\"指定目录\"); 案例(删除非空目录) 方法1 12345678910111213141516public static void delete1(File file) &#123; if (file.exists()) &#123; if (file.isFile()) &#123; file.delete(); &#125; else &#123; File[] list = file.listFiles(); for (File file2 : list) &#123; file2.delete(); &#125; file.delete(); syso(\"删除完毕\"); &#125; &#125;else &#123; System.out.println(\"要删除的文件或目录不存在\"); &#125;&#125; 方法2(return)迭代方法 123456789101112131415public static void delete2(File file) &#123; if(!file.exists()) &#123; return; &#125;else if(file.isFile()) &#123; file.delete(); return; &#125;else &#123; File[] files = file.listFiles(); for(File file2 :files) &#123; delete2(file2); &#125; file.delete(); &#125; System.out.println(\"删除完毕\");&#125; 2.FileNameFilter​ 函数式接口 实现方法: 新建类实现FileNamefilte,重写accept(File dir,String name)方法 dir:父目录,name:字文件目录名称 1中类返回满足的要求 案例 123456public boolean accept(File dir, String name) &#123; boolean endsWith = name.endsWith(\".f\"); //name只有new File才能使用File的方法 //boolean directory = new File(name).isDirectory(); return endsWith;&#125; FileNameFilter与FileFilter的区别 传入参数不同,FileFilter也实现accept但是传入(File file)方法 FileFilter不适用于file.list()方法 2.byte 字节换算 1KB=1024B=1byte(字节)=8bit(比特) 1B(字节)=8b(比特) UTF-8 字符集 中文 英文 UTF8 3个字节 1个字节 GBK 2个字节 1个字节 byte[]转换 String转换为byte[] 1byte[] bates = str.getBytes(\"字符集\"); byte[]转换为String 1String str = new String(bates,\"字符集\"); 3.RandomAccessFile1.基础知识 所属类 java.io.RandomAccessFile 作用: 进行文件的byte单字节读写 原理: 指针读取: 每写入1byte(字节),指针移动1个位置. 同一个raf对象指针的位置不重置为0的,如果要读取,要先raf.seek(0); 不同的raf默认指针位置为0再次写操作会覆盖写入的部分; 由于第一次写入1个String类型占3个字节,第二次写入一个int类型占2个字节,还剩余一个字节就会抛出EOFException异常 1234dyte[] dates = new dates[];String str = new String (\"x\",\"字符集\");raf.seek();raf.writeInt(1); 2.相关方法 创建对象 如何file为r,而选择rw访问模式则直接报错 r:读:如果写操作会抛出io异常 rw:读写:如果没有文件会尝试创建文件 1RamdomAccessFile raf = new RamdomAccessFile(file,\"rw\"); 写入 char/ASCII写入 1read.write(); 写入数组大小数据并导入数组中 1read.write(dates); 写入数组n1-n2位置数据并导入数组中 1read.write(dates,n1,n2); int/double/其他类型 当读取到末尾时会抛出EOFException 1raf.writeInt();/raf.writeUTF(); UTF 虽然传入的是String类型内容,但是写入的是不同类型(“1”–int/“你好”–String) 1raf.UTF(\"1\");/raf.UTF(\"你好\"); 读取 char/ASCII读取(文档不乱码) 1raf.read(); 读取数组大小数据并导入到数组中 1raf.read(dates); int/UTF(不乱码)读取 1raf.readInt();/raf.readUTF(); 指针 单位是byte(字节) 当前指针位置 1raf.getFilePoint(); 指定指针位置 1raf.seek(0); 当前总指针数/文件大小 1raf.length(); 关闭流 1raf.close(); 3.案例1.String写入或读写 写入 123String str = \"x\";byte[] bytes = str.getBytes(str,\"字符集\");raf.write(bytes); 读取 1234raf.seek(0);byte[] bytes = new byte[raf.length()];raf.read(bytes);String str = new String(bytes,\"字符集\"); 2.ASCII和char写入或读写 写入 1raf.write('a');/raf.write(49); 读取 1234int code = -1;while((code=raf.read()) != -1)&#123; syso(code);&#125; Other写入或读写(readInt/readUTF) 写入 1raf.writeInt(123);/raf.UTF(\"123\"); 读取 123while(raf.getFilePoint != raf.length())&#123; raf.read();&#125; 3.文件复制123456789101112131415161718192021RandomAccessFile raf1 = null;RandomAccessFile raf2 = null;try &#123; raf1 = new RandomAccessFile(file, \"rw\"); byte[] bytes = new byte[1024]; raf1.read(bytes); raf2 = new RandomAccessFile(\"D:\\\\B.txt\", \"rw\"); raf2.write(bytes); System.out.println(\"复制成功\");&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally&#123; try &#123; raf1.close(); raf2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 5.Other","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"}]},{"title":"JavaOOP","slug":"JAVA/JavaOOP","date":"2019-11-01T12:02:42.000Z","updated":"2019-11-06T03:36:22.439Z","comments":true,"path":"2019/11/01/JAVA/JavaOOP/","link":"","permalink":"https://airbash.cn/2019/11/01/JAVA/JavaOOP/","excerpt":"","text":"0.基础信息1.权限 详细信息 四大权限 默认都可以访问本类 public(公共访问权限):最高权限,任何类都可以使用 private(本类访问权限):最低权限,只有本类可以使用 protected(子类访问权限):同包类和子类 default(包访问权限):只有同包类可以访问 权限 类 public 方法 public private protected 局部变量 不可使用,跟方法权限相同 成员变量 public private protected 默认 2.重置1.重写 规则(两同两小一大): 两同:派生类的方法名/参数列表与超类完全相同 两小:派生类的返回值/异常小于或等于超类 一大:派生类的访问权限大于或等于超类 2.重载 规则 参数名相同 参数列表不允许重复 3.造型1.向上造型向上造型时父类对象只能使用父类的方法,如果子类重写方法则使用的就是子类方法,不能再使用子类的方法; 原本的子类对象变为父类对象提高了兼容性和可操作性; 12B extends A();A a = new B(); 重写是虚拟机运行期执行， 根据对象的不同而不是引用类型的不同，去调用不同的版本。 2.向下造型类似于强制类型转换,用于将向上造型的父类强制转换为子类,只能转换为对应的子类否则会报错 1B b = (B)a; 4.比较 比较符号 特点 == 判断两侧的引用在栈中对应的内容是否相同 equals instanceof 1.左侧引用类型obj,右侧类名class2.判断obj是否是class类型的之间或间接子类 1.==2.equals 比较公式: 1obj1.equals(obj2); 注意事项: 在object中默认equals方法,单纯的==，可以重写，多数类中已经重写过了,实际环境中创建实体类时可以重写(可以使用编辑工具自行生成); obj1是null的话会引发空指针异常,因此在实际环境中,比较把已知不为空的写在左侧. 源码: Object原始方法 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 重写 1 3.instanceof 比较公式: 1obj instanceof Class 注意事项: obj必须为引用类型,不能是基本类型; obj为null,则返回false; Obj obj=new class(),则返回true; class是obj的直接或间接父类,返回true; obj是数组时,只有object返回true; 1.修饰符1.final 修饰对象 作用 注意事项 类 不能被继承 方法 不能被重写 引用 引用:不能被修改(不能指向别的对象);指向的对象:可以被修改 适用情况:方法的参数/实例化 变量 不能被重新赋值 局部变量:在使用之前被初始化赋值就行;成员变量:必须直接初始化; 1234//局部变量赋值的两种方法final int x=10;final int y;y=20; 2.static 静态内容可以被多个对象所共享,因此一个对象修改后其他对象再次引用的是修改后的内容; 静态内容不能直接访问非静态内容(因为类加载的时候就会先加载静态内容,再加载实例,因此执行顺序也高); 静态内容就不再属于对象而是属于类,所以存储在方法区; 静态方法调用可以类名点,也可以引用点(但是不推荐); 静态方法不能使用this:因为this代表当前对象,而静态方法属于类,因此不能使用; 3.abstract 抽象方法: 抽象方法必须被重写; 如果继承抽象类的是普通类,那么抽象方法必须被重写.如果继承抽象类也是抽象类那么抽象方法可以只继承不重写; 抽象方法没有方法体(没有{}); 抽象类: 不能实例化,只有被继承才能有意义; 抽象类内的构造器,主要继承给子类创建实例时使用.抽象类的普通方法主要是继承给子类使用的(); 含有抽象方法的类一定是抽象类.但是抽象类中可以不含有抽象方法; 注意事项: abstract不能和final和static一起使用; final修饰的类不能被继承,修饰的方法不能被重写,而abstract修饰的类必须要被继承,修饰的方法必须被重写 static修饰的方法就不再属于类,用类名就可以调用,但是如果使用abstract修饰的方法,用父类直接调用就会导致调用一个没有方法体的方法; abstract不能修饰变量和构造器; abstract不能定义为private访问权限; 2.修饰符相关1.变量1.定义变量 直接赋值 1int a =1; 先声明再赋值 12int a;a=20; 2.命名规则 只能包含字母、数字、_、$,不能用数字开头; 区分大小写; 不能使用关键字; 建议使用英文/见名知意/驼峰命名法 3.分类 根据位置不同 分类 分类依据 内存 成员变量 类中的变量 成员变量在对象中,对象被回收,成员变量失效; 局部变量 方法中的变量 局部变量在方法中,方法执行完毕,局部变量失效; 根据修饰符 分类 分类依据 内存 实例变量 没有被static修饰 实例变量属于对象,保存在堆中,有几个对象就保存几份 静态变量 被static修饰 静态变量属于类,保存在方法区中的静态区,只保存一份 4.优先级局部变量&gt;&gt;&gt;成员变量 2.常量1.定义常量被final static同时修饰的成员变量(不能定义在方法内) 1final static int A_A =1; 2.命名规则类似变量的明明规则,但是全部使用大写,单词之间用_连接 3.接口1.基础信息[]部分可以省略不写,编译器自动补全; 属性 修饰符 JDK 注意事项 接口 public [abstract] interface 1.7 1.一个类可以实现多个接口;2.一个接口可以继承多个接口,抽象方法可以重复; 常量 [public static final] 1.7 1.接口中没有成员变量只有常量;2.只能通过接口名调用或者被默认方法引用 抽象方法 [public abstract] 1.7 必须被重写 默认方法 [public] default 1.8 1.实现功能的方法,类似抽象方法中普通方法;2.可以引用接口中所有类型的方法；3.可以被重写,修饰符变为public;4.实现后不会出现空方法,接口增加方法不用修改所有实现类; 静态方法 [public] static 1.8 1.不能通过对象进行调用,只能通过接口名调用2.只能通过接口名调用或者被默认方法引用3.可以被重写; 私有方法 private 1.9 默认方法的私有方法 静态私有方法 private static 1.9 静态方法的私有方法 2.函数式接口函数式接口 只包含一个抽象方法的接口,java8专门为函数式接口提供了@FunctionalInterface注解 3.内部类 外部类不能直接访问内部类,内部类成员可以访问外部类的私有数据; 外部类不可以使用”private/protected/static”修饰符 1.成员内部类 区别 名称 区别 注意事项 静态内部类 使用static修饰的成员内部类 不能有静态方法/静态成员变量/静态初始化块 非静态内部类 不使用static修饰的成员内部类 static关键字的作用 外部类的外一层是包不能用static修饰;内部类的外一层是外部类能用static修饰; 把内部类变成外部类的类相关,而不是外部类的实例(对象)相关; 查找变量顺序 内部类局部变量&gt;&gt;&gt;内部类成员变量&gt;&gt;&gt;外部类成员变量 保存文件形式 外部类:外部类名.class 内部类:外部类名&amp;内部类名.class 1.非静态内部类 外部类访问内部类: 在外部类方法内新建内部类访问内部类,main方法不能新建非静态内部类对象(编译错误) 1234567class out&#123; class Int&#123; &#125; public static void main(String[] args)&#123; Int int = new out.new Int(); &#125;&#125; 可以访问内部类方法,但是不能访问内部类变量(编译出错); 内部类访问外部类:都行 2.静态内部类 外部类访问内部类: 在外部类方法内或main内都能新建对象或者直接内部类名调用; 1234567class out&#123; static class Int&#123; &#125; public static void main(String[] args)&#123; Int int = new out.new Int(); &#125;&#125; 可以访问内部类变量,但是不能访问内部类方法(编译出错); 内部类访问外部类: 静态内部类不能访问外部类的实例成员,只能访问外部类的类成员; 静态内部类对象只持有外部类的类引用,没有持有外部类的对象引用 静态内部类可以包含静态成员,也可以包含非静态成员; 接口内部类[了解即可] 只能使用public static修饰接口内部类; 接口的作用是定义一个公共规范(暴露出来供大家使用),如果把这个接口定义成一个内部接口就没有意义了; 2.局部内部类3.匿名内部类 要求: 必须且只能实现或继承一个类; 继承只是单纯的新建类+重写需要用到的内容; 匿名内部类不能是抽象类(没有意义),不能定义构造器(没有类名); 匿名内部类是:需要创建并使用一次的类; 书写格式 继承: 123new 父类([参数])&#123; 重写&#125; 实现: 123new 实现类()&#123; 重写&#125; 匿名内部类使用外部类成员内部类时,成员内部类必须要被final修饰,java1.8以后自动在编译时在成员变量前添加final 案例: 父类 1234567891011public class Father &#123; public Father(String name) &#123; super(); Name = name; &#125; 省略:有参无参构造器 private String Name; private Integer age; private String Book; 省略:get/set方法&#125; 外部类: 12345678910111213141516public class Test&#123; public void father() &#123; //java1.8后自动在成员变量前加上final,再次复制则编译错误 String book=\"数学\"; //book=\"12\"; Father father = new Father(\"刘备\") &#123; public Integer getAge() &#123; return 10; &#125; public String getBook() &#123; return book; &#125; &#125;; System.out.println(\"姓名:\"+father.getName()+\",年龄:\"+father.getAge()+\",书籍:\"+father.getBook()); &#125;&#125; 4.Lambda表达式 作用: 在java8以后允许将代码作为参数传入方法中; 允许用更简洁的代码来创建函数式接口; 匿名内部方法,所以只有一个方法 表达式 1234(Integer a1,Integer a2,...)-&gt;&#123; 代码块; return x;&#125; 简写 只有一行代码时,可以省略{} 1(Integer a1,Integer a2,...)-&gt;代码1; 只有一个参数时,可以省略() 1Integer a1-&gt;&#123;代码1;代码2&#125;; 没有参数时,必须书写() 1()-&gt;Integer a1-&gt;&#123;代码1;代码2&#125;; 代码块只有一行代码,代码值就是表达式返回值 1Integer a1-&gt;X x = new x; 极简 1()--&gt;代码; X 将Lambda表达式赋值给函数式接口类型的变量. 将Lambda表达式作为函数式接口类型的参数传给某个方法. 使用函数式接口对Lambda表达式进行强制类型转换. Lamdba表达式实现的匿名方法与目标类型中惟一的抽象方法有相同的参数列表 Lamdba表达式也可以强制转换为带参数的表达式 4.内存 存储内容 存储 内容 栈 引用(堆内存地址)、栈帧(方法(局部变量+参数))、基本数据类型 堆 对象/实例变量 方法区 类文件的字节码信息/静态内容(静态区) 1. 栈帧每调用一个方法,jvm就会在栈中为方法创建一个栈帧用于存储:方法(局部变量+参数),方法执行完后栈帧消失 2.内存 内存泄露： 不再使用的内存(栈或堆)还没有被及时的的回收 垃圾回收: 垃圾回收期（CG）不定时到内存堆中清扫垃圾(没有任何引用所指向的对象)。 并不一定发现垃圾就立刻回收 不能控制垃圾的回收只能通过调用System.gc()建议JVM尽快调度GC来回收 3.方法区 在产生栈堆关系之前,会通过类加载器载入类文件的字节码信息,经过解析后类的信息装入方法区.类的信息包括成员变量/方法定义/静态内容,并只保留一份; 内容 123456类名.class&#123; 成员变量1;成员变量2; 方法名()&#123; &#125; 静态方法&#125; 4.事例 实例1 12345678public static void main(String[] args) &#123; Double price= 12.5; test1(\"数学\", price);//调用完test1方法之后,此栈帧消失 System.out.println(price);&#125;public static void test(String aname,Double price) &#123; price = price+10;&#125; 此时card为同一对象 123456789public static void main(String[] args) &#123; Integer age = 20; Father father = new Father(age); test2(\"代维\",father); System.out.println(father.age);&#125;public static void test(String name,Father father) &#123; father.age+=20;&#125; 5.GC回收 解决方法: 建议GC回收上 1System.gc(); 查看内存占用情况 获取Runtime对象 1Runtime runtime = Runtime.getRuntime(); 获取jvm所占最大内存 1runtime.maxMemory()/1024/1024+\"M\" 当前jvm所占最大内存 1runtime.totalMemory()/1024/1024+\"M\" 剩余内存 1runtime.freeMemory()/1024/1024+\"M\"","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"}]},{"title":"JavaBase","slug":"JAVA/JavaBase","date":"2019-11-01T11:55:40.000Z","updated":"2019-11-06T03:36:22.438Z","comments":true,"path":"2019/11/01/JAVA/JavaBase/","link":"","permalink":"https://airbash.cn/2019/11/01/JAVA/JavaBase/","excerpt":"","text":"1.基础知识1.java专用词 名词 作用 注意事项 实例化 能new xxxx(); 不能实例化的:接口/抽象类 引用数据类型 除了基本的数据类型以外的类型: String/接口(API)/数组 对象 new Person(); 一个对象可以被多个引用所指向 引用 Person person 一个引用可以指向多个对象,全称`引用对象变量 2.java环境 编译过程: 编译期:java源文件,经过编译,生成.class字节码文件 运行期:JVM加载,class并运行.class 跨平台,一次编译到处使用 详细: JVM:java虚拟机 加载.class并运行.class JRE:java运行环境 JRE=JVM+java系统类型(小零件) JDK:java开发环境 JDK=JVM+编译运行等命令工具 2.数据类型1.基本数据类型 列表 所属类型 基本类型 bit byte 范围 注意 整数类型 byte 8位 1 -128/127 short 16位 2 -32768/32767 int 32位 4 -21亿/21亿 默认类型 long 64位 8 灰常大 长整型直接量需要在数字后加L或l 浮点数类型 float 32位 4 可能出现舍入误差,单精度 double 64位 8 可能出现舍入误差,双精度 默认类型 字符型 char 16位 2 采用Unicode字符集编码，一个字符对应一个码,表现形式为字符char，但本质上是码int(0到65535之间) (ASCII: ‘a’–97 ‘A’–65 ‘0’–48) 布尔型 boolean 只能赋予true和flase,不进行类型转换 案例 123456char a = &apos;42&apos;;System.out.println(a);//输出42char a = 42;System.out.println(a);//输出42对应值char a = &quot;42&quot;;System.out.println(a);//输出字符串42 2.运算规则 整数相除时,小数位舍去; 整数直接量可以直接赋值给byte,short,char类型; 运算时超出数据类型的范围会溢出; byte,short,char型数据参与运算时,先一律转换为int再运算(比int类型位数低的); 直接写代表的是默认值,因此需要强转,而+=默认强转 3.类型转换 byte&lt;short&lt;int&lt;long&lt;float&lt;double&lt;char 自动转换(从小到大) 强制转换(从大到小) (数据类型)(a+b); 3.分支结构4.循环结构1.三目?相当于if|:相当于else if 1a&gt;100?b=100:a&lt;100?b=200:300 2.if!flag相当于flag=false 123if(!flag)&#123; &#125; 3.循环控制 循环控制 作用 注意事项 a: 标识符:写在外层循环前面,循环控制后写标识符名a 写了标识符下列可对外层循环进行控制 return 退出所有循环 可以有返回值 break 退出本次循环 1.可以紧跟标识符;2.建议与if一起用 continue 忽略本次循环剩下的内容 1.可以紧跟标识符;2.必须与if一起用 5.数组1.基础知识 缺点: 数组定长不可变(复制新数组); 不能保存有映射关系的数组; 声明方式: 12Int[] arr;Int arr[];//不推荐 2. 初始化 动态初始化:在声明时赋默认值 声明: 1int[] arr = new int[3]; 赋值: 1arr[0]=1;arrr[1]=1;arrr[2]=1; 静态初始化:在声明时赋值 方法一: 1int[] arr = new int[]&#123;2,5,8&#125;; 方法二:必须在声明时初始化 1int[] arr = &#123;2,5,8&#125;; 默认值: 声明数组后若不初始化,则赋予默认值; 类型 默认值 int 0 double 0.0 boolean False 引用类型 null 3.使用 数组长度 1int x = arr.length(); 数组的编历 123for(int i;i&lt;arr.length;i++)&#123; System.out.print(arr[i]);&#125; 数组下标越界异常(java.ArrayIndexOutOfBpundsException:N) 当使用和赋值超过数组下标的大小时就会发生数组下标越界异常 4.案例 数组的复制： System.arraycopy() 用于将一个数组的部分值复制到一个存在的数组中; 1234//将数组arr1从0开始的3个元素复制到arr2从1开始的3个位置上int[] arr1 = &#123;1,2,3,4,5&#125;;int[] arr2 = new int[5];System.arraycopy(arr1,0,arr2,1,3); Arrays.copyOf() 赋值产生新数组 123//用arr1的前n个元素复制出一个新的数组arr2,不够的用默认值补齐,多出来的删除int[] arr1 = [&#123;1,2,3,4,5&#125;;int[] arr2 = Arrays.copyOf(arr1,n); 扩容 1int[] arr3=Arrays.copyOf(arr,arr.length+1); 数组的排序： 比较各种方法所需时间的方法 1234long a = System.curretTimeMillis();//排序命令long b = System.curretTimeMillis();System.out.println(b-a); Arrays.sort(arr);最快//计算升序（用于数组）； 冒泡排序：从第一个元素开始到倒数第二个元素终止，与剩下的数进行比较，移位","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://airbash.cn/tags/JAVA/"}]},{"title":"Redis","slug":"数据库/Redis","date":"2019-11-01T10:31:03.000Z","updated":"2019-11-06T03:36:22.454Z","comments":true,"path":"2019/11/01/数据库/Redis/","link":"","permalink":"https://airbash.cn/2019/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/","excerpt":"","text":"1.基础知识 版本 3.x之前不支持分布式安装 3.x之后支持分布式安装 优缺点 单个redis容易发生单点故障,一台服务器很难处理大量内存. redis可用的存储空间有限,即使是打野不能用 1.基础配置./redis/redis.conf 名称(默认) 作用 行号 注意事项 bind 127.0.0.1 可以连接的地址 69 注释掉设置为远程登录 port 6379 端口号 93 自行设置 timeout 0 设置超时断开时间 113 自行设置 daemonize no 设置为守护线程 136 yes:守护线程 pidfile /var/run/端口号.pid 设置pid的文件 159 只有设置为守护线程才生效 loglevel verbose 日志级别 debug、verbose(默认)、notice、warning logfile 日志文件位置 设置日志保存文件 172 设置为守护线程默认为:/dev/null(黑洞) databases 16 设置存储库数量 187 默认16个 save 10 1 10秒钟有1个key持久化到硬盘 219-221 三个条件满足其中一个就进行RDB持久化 rdbcompression yes 本地存储数据是否进行压缩 252 yes:开启默认开启 dbfilename 持久化文件 设置持久化备份的库文件 254 dir 指定数据存储位置 指定数据库保存的位置 264 默认redis目录下 requirepass foobared 设置密码 508 默认注释(redis3.0之后必须设置),通过”-a 密码”进行连接,明文书写即可,java通过auth连接 maxclients 设置并发线程连接数 540 默认注释没有限制 maxmemory&lt;bytes&gt; 指定Redis最大内存 567 默认注释,默认值256M(建议1g分配256-512) 2.内存淘汰机制只需要配置一个模式 名称 作用 注意事项 volatile-lru 删除最不常用的超时数据 后面配置超时时间 allkeys-lru 查询所有key中最近最不常使用的数据进行删除 常被配置的模式 volatile-random 随机删除超时数据 后面配置超时时间 allkeys-random 查询所有数据后随机删除 volatile-ttl 查询所有超时数据,排序后删除 后面配置超时时间 noeviction 不进行处理,内存溢出时报错 默认配置 volatile-lfu 在所有超时数据中驱逐使用频率最少的键 4.0新功能 allkeys-lfu 在所有键中驱逐使用频率最少的键 4.0新功能 常见配置 2.redis命令1.共有命令操作成功几个数据返回几 1.多数据库 select:切换数据库 [0-15]默认16个数据库 1select n move:移动数据到另一个数据库 1move key n flushdb:删除当前数据库的所有key 1flushdb flushall:删除每个数据库的所有key 1flushall 2.其他 查看所有key 1keys * 删除key 1del x [y..] 检测是否含有key 1exists x [y..] 清除时间 设置清除时间 秒 1expire x 10 毫秒 1pexpire x 1000 查看清除时间 返回值 返回值 作用 注意事项 -1 永久有效 -2 无效 &gt;0 剩余时间 秒 1ttl x 毫秒 1pttl x 设置为永久有效 1persist x 返回随机KEY[不常用] 1random key 重命名KEY 1rename x y 查看数据类型 1type x 序列化 1dump x 2.String最大的key为512mb,不会发生编码异常,在客户端编解码 用途:用户限制登录 set增加数据 可以覆盖之前的数据和类型 1set str 10 mset批量增加 1mset str1 10 str2 x str3 20 查看一个数据 1get string 1key sitring:?[1,2] 批量查看 1mget str1 str2 str3 getrange截取 1getRange str n1 n2 getset返回之前的值,设置新值 12getset str 15//输出nilgetset str 10//输出10 strlen长度 1strlen str append判断追加 key存在时追加值,key不存在时赋值 1append str 10 setnx 判断赋值 key存在时不进行操作,key不存在时赋值 1setnx str 10; 加减操作 只能对String类型的数值进行操作,以0开头的数值视为字符串,不书写n时为加减1,0不存在时从0开始计算 加1 1incr string 减1 1desr string 自增n 1incrby str n; 自减n 1decrby str n; 添加一个n秒的临时数据 1setex str n value 3.Hash存储对象,类似于HashMap hset添加对象的一个属性 1hset user:1 id 1 hmset批量添加对象的多个属性 1hmset user:1 id 1 name zhangsan hget 获取对象的一个属性值 1gset user:1 id hmset批量获取对象的多个属性值 1hgset user:1 id name hgetall获取对象的所有属性名和属性值 1hgetall user:1 hdel删除对象的一个或多个属性 1hdel user:1 id [user] hsetnx存在属性时不操作,不存在属性时添加 1hsetnx user:1 id 1 hexists检测是否存在属性 返回值存在个数 1hexists user:1 id [name...] 4.List用途:做流程 类似于linkedList lpush(从左侧(头部)开始添加,最先添加的是尾部最后一个) 1lpush friend x [x] [x] rpush(从尾) 1rpush friend x [x] [x] rpushx:最右侧添加(不受1/2的影响) 1rpushx key x lpushx:最左侧添加(不受1/2的影响) 1lpushx key x lrange:查看n1-n2的值(可以实现分页) 负数代表从后开始数第几个,例如-1代表最后一个 1lrange friend n1 n2 lpop:从头部弹出,弹出就没了(删除) 1lpop friend rpop:从尾部弹出 1rpop friend brpop:从头部弹出,没值的话等待1000秒,有值就弹出(等待时代表全部弹出,这个key就被删除了,需要重新赋值) 1blpop key 1000 blpop:从尾部弹出,如果在1000秒之后有值就弹出 1blpop key 1000 rpoplpush:从friend1右侧弹出从friends头部插入 1rpoplpush friend1 friend2 lset:更改下标为n的key的值为x 1lset key n x linset:将x插入下标为n的key的前面或后面 1linsert key before|after n x llen:长度 1llen key lindx:显示下标为n的key值 1lindex key n 5.Set类似于hashtable:无序不重复 sadd:添加数据 1sadd key a b c scard:获取数据数 1scard key smembers:获取所有数据 1smembers key sismember:查询是否存在a数据 1sismember key a srandmember:返回集合中一个或n个数据 1srandmember key [n] srem:删除key中的一个或多个数据 1srem key a [b] spop:随机删除key中一个或n个数据并返回删除的值 1spop key [n] smove:将一个数据移动到另一个key 将key1中的a移动到key2中 1smove key1 key2 a 差集: sdiff:查询交集之外的不相同的数据 1sdiff key1 key2 [key3] sdiffstore:脚趾之外的不同的数据复制到key中 1sdiiffstore key key1 key2 [key3] 交集: sinter:查询共有数据 1sinter key1 key2 [key3] sinterstore:共有数据并复制到key中 1sinterstore key key1 key2 [key3] 并集: sunion:查询所有数据 1sunion key1 key2 [key3] sunionstore:所有数据并复制到可以中 1sunionstore key key1 key2 [key3] 6.Zset用途:排行榜 有序集合且不允许重复,但是通过一个double分数来排列顺序,分数可以重复 zadd:增加一个或多个数据 1zadd key 分数 a [分数 b] zcound:查看分数1-分数2的成员个数 1zcard key 分数1 分数2 zrange:通过从低到高查看下标0-n之间的数据 1zrage key 0 n zrevrange:通过从高到第查看下标0-n之间的数据 1zrevrange key 0 n zrem:删除数据 1zrem key a [b] zremrangebybank:删除下标0-n之间的数 1zremrangebybank key 0 n zremrangebyscore:删除分数之间的数 1zremrangebycore key 分数1 分数2 3.redis操作1.发布订阅 作用: 订阅频道,从而接收数据 subscribe:订阅频道:处于接收状态 1subscribe 频道 [频道1] publish:向指定频道发送信息 1publish 频道 信息 unsubscribe:退订频道 1unsubcribe punsubscribe:退订所有频道 1punsubscribe 2.事务​ 用途:一组行为执行时:秒杀活动 multi:开始事务 1multi exec:执行 数据出错:只有出错的语句不会被执行 语法错误(报告错误):都不会被执行,会自动回滚 1exec discard:回滚(放弃执行) 1discard watch: 监视一个或多个key,如果这个key在事务期间被更改,那么当exec时就会回滚,并取消监视 在multi之前执行,如果执行exci或discard就会自动取消监视 1watch key [key] unwatch:取消所有监视 1unwatch [key] [key] 4.持久化1.RDB 基础知识: 默认开启 定期将内存中的数据做成快照保存在磁盘中 默认存储在redis目录下,名为dump.rdb 优缺点 优点:保存和读取数据都很快 缺点: 小机器不适合做快照 在非正常关机时无法保存 快照条件: 执行shutdown正常关闭时 执行flushall删除所有key时 在指定时间间隔内 执行save命令 恢复rdb: 将dump.rdb文件拷贝到redis下的bin目录即可 2.AOF 基础知识: 执行操作之后会将操作写在日志中,如果出现问题可以回滚 每做一次写操作都会,就会将操作追加到appendoly.aof中,当redis重启时就会重新读取整个数据库 启动AOF,修改配置文件: 启动AOF:699默认no 1appendonly yes 指定存储文件名:703 1appendfilename &quot;appenonly.aof&quot; 指定跟新日志条件:728默认被注释 1appendfsync 条件 always:写操作一次就写入一次: everysec:每秒钟写入一次:性能和持久化居中 no:完全依赖os,性能最好,持久化没保证 配置重写机制 当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。一般都设置为3G，64M太小了。 12auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 恢复AOF 直接复制到bin目录下 通过命令 1redis-check-aof --fix appendonly.aof 5.数据一致性1.实时同步数据库与redis @cacheable:查询时使用,注意Long类型需转换为String类型,否则会抛异常 @CatchPut:更新时使用,使用此注解,一定会从DB上查询数据 @CacheEvicat:删除时使用; @Caching:组合用法: 2.异步队列消息中间件:kafka 3.其他 udf自定义函数 脚本 4.相关知识点 数据库穿透: 可能查询到的是null数据,null数据不会写入redis缓存,而是返回查询失败,更多的人访问最后导致宕机,因此可以设置如果数据库查询到的是null的话就添加key但是值是null; 雪崩: 缓存集中在同一时间段失效,导致大量用户进入数据库查询产生数据穿透 分析用户行为,找到合适的时间点失效 加锁或者队列 缓存预热 热点key: 5.主从复制可以使用阿里插件:canal也可以用下列方法 修改从服务器redis配置文件 port:6380(重新修改端口号):此端口是从服务器的端口号 slaveof 127.0.0.1 6379(指定主服务器和端口号用于连接主服务器) 或者使用命令切换主从服务器 slaveof ip地址 端口号 变回从服务器:只能进行查 slaveof on one 变回主服务器 slavef 查询新的master slaveof new master 6.哨兵模式4.Cluster集群1.基础知识 无中心,无需连接所有的服务器 必须要3master+3slaveof才能配置成集群 共有0-16383共16384个hash曹,个人服务器均分 容错性(投票):当一个服务器在半数以上的服务器无法连接时视为当前无服务挂掉 节点分配:A(0-5460)B(5461-10922)C(10923-1638) 如果增加新的服务器则分别从ABC的前面出去一部分最后达成均分 真集群和假集群以下为假集群的创建规则 2.搭建流程1.修改配置文件 复制配置文件 创建Redis节点安装总目录 1mkdir /usr/local/redis_cluster 创建Redis节点安装目录(复制5份redis配置文件(7001-7005)) 1cp `~/redis.conf /usr/local/redis_cluster/7001/ 修改配置文件 参数 作用 行号 port 7001 修改端口号,6个服务器不同 92 pidfile /var/run/redis-7001.pid 修改pid进程文件.默认以pid命名名称 158 logfile 存放地址/redis.log 修改日志文件地址,可不修改 171 dir 存放地址 修改数据文件存放地址,以端口号为目录名区分,可不修改 263 cluster-enable yes 启用集群 832 cluster-config-file node-7001.conf 修改节点的配置文件 840 cluster-node-timeout 15000 配合集群节点的超时时间,使用默认 846 启动并查看 启动5份redis 1redis-server /配置文件 查看是否启动 1ps -ef |grep redis 关闭reids 1redis-cli -p 7001 shutdown 2.安装软件1.rubyredis-trib.rb的依赖 建议编译安装,而不是下列方法 1yum -y install ruby ruby-devel rubygams rpm-build 2.rvm用于更新ruby,官方文档:https://www.rvm.io/rvm/install stable:最新版 master:最新开发版 安装rvm官方的两个gpg秘钥 标准方法(经常失败:原因未知) 1gpg2 --keyserver hkp：//pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB 替代方法 12curl -sSL https://rvm.io/mpapis.asc | gpg --import - curl -sSL https://rvm.io/pkuczynski.asc | gpg --import - 安装rvm 标准安装 1\\curl -sSL https://get.rvm.io | bash -s stable 使用ruby安装rvm 1\\curl -sSL https://get.rvm.io | bash -s stable --ruby 检验安装情况 1find / -name rvm -print 加载配置文件 普通加载 1source /usr/local/rvm/scripts/rvm 设置环境变量(官方脚本:全局) 1source /etc/profile.d/rvm.sh 升级rvm 1rvm get stable 查看ruby版本 1rvm list known 安装最最新版ruby 1rvm install 2.6.3 使用一个ruby版本 1rvm use 2.6.3 设置默认ruby版本 1rvm use 2.6.3 --default 查看ruby版本 1ruby --version 安装redis与ruby整合工具 1gem isntall redis 3.创建启动 创建redis_cluster 3.0-4.0 1redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.1:7005 5.0:不需要安装ruby 1redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1 先出的结果为主,输入yes 连接reids -c:连接集群 -p:访问7001 1redis-cli -h 127.0.01 -c -p 7001 查看节点测试:redis命令 1info replication 查看所有节点信息:redis命令 每个节点都有一个id,用节点来对应,可以更改端口号 主用来set,从用来get,若果set就会跳到get中 1cluster nodes 4.集群管理 添加单个集群 1add-node 删除单个集群 1del-node 删除全部集群 关闭所有集群 删除nodes-port.conf配置文件 重建集群 4.相关方法 新建对象 12345678910111213141516@Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; public String getString(String username) &#123; ValueOperations&lt;String, String&gt; string = redisTemplate.opsForValue(); if(redisTemplate.hasKey(username)) &#123;//redis中有,直接输出 System.out.println(\"在redis中查找:\"); return string.get(username); &#125; else &#123;//redis中没有数据,在mysql中查找后赋值(模拟),并输出 String age=\"15\"; string.set(username, age); System.out.println(\"在mysql中查找:\"); return age; &#125; &#125; 语法规律 公用redis语法对应redisTemplate静态方法 私有redis语法对应redisTemplate.ospFor***()","categories":[{"name":"数据库","slug":"数据库","permalink":"https://airbash.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://airbash.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"https://airbash.cn/tags/Redis/"}]},{"title":"Oracle","slug":"数据库/Oracle","date":"2019-11-01T10:21:32.000Z","updated":"2019-11-06T03:36:22.453Z","comments":true,"path":"2019/11/01/数据库/Oracle/","link":"","permalink":"https://airbash.cn/2019/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/","excerpt":"","text":"1.基础内容1.基础配置1.下载安装 基础知识: Oracle分为服务端和客户端两种; 安装了服务端就不需要安装客户端,服务端内包含客户端; 下载数据库: 这里选择的是oracle11g快捷版,与普通版相比缺少个别不常用功能,但是却节约内存和磁盘空间,适用于开发使用; 安装数据库: 设置密码时不能使用标点符号; 2.启动关闭 使用软件自带的bat脚本; 使用自制数据库脚本,用管理员权限运行; 12345678910111213141516171819202122@echo offfor /f \"skip=3 tokens=4\" %%i in ('sc query OracleXETNSListener') do set \"zt=%%i\" &amp;goto :next:nextif /i \"%zt%\"==\"RUNNING\" (echo 已经发现OracleXETNSListener在运行，现在已经停止运行net stop OracleXETNSListener) else (echo OracleXETNSListener现在处于停止状态,将进行启动net start OracleXETNSListener)pausefor /f \"skip=3 tokens=4\" %%i in ('sc query OracleServiceXE') do set \"zt=%%i\" &amp;goto :next:nextif /i \"%zt%\"==\"RUNNING\" (echo 已经发现OracleServiceXE在运行，现在已经停止运行net stop OracleServiceXE) else (echo OracleServiceXE现在处于停止状态,将进行启动net start OracleServiceXE)pause 3.配置文件与mysql不同的是oracle远程连接需要单独的配置文件,并将配置文件的地址写在环境变量中 1.基础配置文件oci.dll文件位置:oracle\\product\\11.2.0\\server\\bin\\oci.dll 2.三大配置文件配置文件位置:oracle\\product\\11.2.0\\server\\network\\ADMIN\\ listener.ora 事例 123456789101112131415LISTENER_CSA = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = ip地址)(PORT = 1521)) ) ) )SID_LIST_LISTENER_CSA = (SID_LIST = (SID_DESC = (ORACLE_HOME = oracle根目录) (SID_NAME = 实例名称) ) ) sqlnet.ora 可以删除,删除后默认使用tnsnames.ora内的配置 tnsnames.ora 作用: 配置基础的远程连接的端口号和ip地址 实例 12345678自定义服务名 = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = IP地址)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = 自定义服务名) ) ) 2.基础知识1.注意事项 在oracle中除了别名外都用单引号,别名用双引号或者直接写. 别名用as连接或空格连接 create or replace:有则创建,无则修改:视图/触发器/存储/触发器 虚表:dual;伪列:自己写的列 2.体系结构 结构 作用 注意事项 数据库 一个数据库可以有多个实例; 事例 不同的实例可以创建相同的用户名; 用户 一个用户至少有一个表空间 类似于mysql里的库 表空间 ora或者dbf的数据文件在oracle中宏观 数据 oracle存储文件:ora或者dbf格式文件 3.基础用户在安装过程会提示重新修改密码sys和system等默认开启的账户密码 用户 默认密码 作用 注意事项 sys change_on_install 拥有最高权限dba,不能用normal登录,执行数据库的管理任务，实例的数据字典都在SYS下 默认开启 system manager 没有最高权限,只能用normal登录,用于执行数据库管理任务，有少量的实例对象 默认开启 scott TIGER 测试账户,用户普通用户权限 没有scott用户则,可以手动执行:官方脚本创建账户 internal oracle anmonymous ANONYMOUS 用于访问ORACLE XML DB知识库的帐户。 dbsnmp DBSNMP 具有NNECT\\RESOUCEHE\\SNMPAGENT 权限的角色，可用CATNSMP.SQL脚本删除此用户和角色 sysman OEM_TEMP 企业管理器OEM密码 outln OUTLN 有CONNECT和RESOURCE角色 4.权限角色oracle自创的权限集合 角色 作用 注意事项 connect 连接角色 基本角色 resource 开发者角色 dba 超级管理员角色 3.其他内容1.基本数据类型 基本数据类型 类型 含义 存储描述 备注 VARCHAR2 可变长度的字符串, 0-4000bytes,可做索引的最大长度749 常用:oracle特有类型,考虑兼容性用varchar NUMBER(m,n) 数字类型 m为总位数,n为小数位,m-n为整数位 常用:既可以存储整数,又可以存储小数 DATE 日期（日-月-年） DD-MM-YY(HH-MI-SS) 常用: CHAR 固定长度字符串 0-2000bytes INTEGER 整数类型 小的整数 LONG 超长字符串 最大长度2G,足够存储大部头著作 FLOAT 浮点数类型 NUMBER(38)，双精度 TIMESTAMP 日期（日-月-年） DD-MM-YY(HH-MI-SS:FF3) DECIMAL(P,S) 数字类型 P为整数位，S为小数位 REAL 实数类型 NUMBER(63)，精度更高 NCHAR 根据字符集而定的固定长度字符串 0-2000bytes NVARCHAR2 根据字符集而定的可变长度字符串 0-4000bytes oracle特有类型,考虑兼容性用varchar 二进制数据类型 类型 含义 存储描述 备注 CLOB 字符数据 最大长度4G BLOB 二进制数据 最大长度4G NCLOB 根据字符集而定的字符数据 最大长度4G BFILE 存放在数据库外的二进制数据 最大长度4G RAW 固定长度的二进制数据 最大长度2000bytes 可存放多媒体图象声音等 LONG RAW 可变长度的二进制数据 最大长度2G 可存放多媒体图象声音等 ROWID 数据表中记录的唯一行号 10bytes \\..\\格式，*为0或1 NROWID 二进制数据表中记录的唯一行号 最大长度4000bytes 2.sql语句 名称 名称 语句 注意事项 DDL 数据定义语言 create/drop/alter DML 数据操纵语言 insert/delete/update/select DCL 数据控制语言 grant/revoke/事务/安全 3.约束详见mysql相关约束 2.基础命令1.表空间 创建表空间 1create tablespace 表空间名 datafile '路径\\文件名.dbf' size 空间大小 [autoextend on next 10m]; 创建用户并指定表空间 1create user 用户名 identidfied by 密码 defalult tablespace 表空间名; 给予用户权限 1grant 角色 to 用户名; 删除表空间 1drop tablespace 表空间名; 2.表操作 创建表 1create table 表名(字段名1 约束,字段名2 约束...); 从其他表拷贝结构 用户名.表名:从其他用户中导入 1create table 表名 as select查询表结构; 删除表 彻底删除: 1drop table person; 初始化表:计数器重置,索引删除,不能用于视图,相当于删除以后重建 1truncate table person; 查看当前用户下的所有表 1select table_name from user_tables 3.记录操作默认使用了事务,建议使用commit 增加记录 标准写法 1insert into 表名 (列名1,列名2...) values (值1,值2...)[,(值1,值2...)...]; 简单写法 1insert into 表名 values (值1,值2...)[,(值1,值2...)...]; 修改记录 1update 表名 set 列名1=值1 [,值2=值2...] [where 条件]; 删除记录 不加条件默认删除所有记录 1delete from 表名 [where 条件]; 4.列操作可以通过(,)进行分割添加修改多个字段 添加记录 1alter table 表名 add 列名 列类型; 修改类型 1alter table 表名 modify 原列名 新列类型 修改名称 1alter table 表名 rename column 原列名 to 新列名 删除字段 1alter table 表名 drop column 列名 3.查询操作1.查询函数1.字符函数 函数 作用 注意事项 upper(‘字符’) 转换为大写字母 只处理英文字符,其他字符不做处理直接输出 lower(‘字符’) 转换为小写字母 只处理英文字符,其他字符不做处理直接输出 2.数字函数 函数 作用 注意事项 round(num,n) 四舍五入num,并保留n位 负数代表整数位,不写n代表0保存到个位, trunc(num,n) 截取到有效位数 负数代表整数位,不写n代表0保存到个位, mod(num,n) 求余数 一般不用 3.日期函数可以直接在时间上进行算数操作 函数 作用 注意事项 sysdate 当前时间 单位天 months_between(d1,d2) d2与d1之间时间差 单位月 4.转换函数 函数 作用 注意事项 to_char(时间,格式化) 将时间类型转化为char类型 to_date(‘时间’,格式化) 将char类型转化为时间类型 格式化不区分大小写 格式化 作用 注意事项 YYYY 年 几个Y显示几位数 MM 月 DD 日 一个D:周几,三个D:一年中第几天 HH12/HH 12小时 HH24 24小时 MI 分钟 SS 秒 5.通用函数 函数 作用 注意事项 nvl(a,b) 如果a为null则显示b 6.多行函数聚合函数:需要查询1条或多条记录 函数名 作用 注意事项 count() 统计记录数 max() 最大值 min() 最小值 avg() 平均值 sum() 求和 2.条件表达式1.case表达式 当查询结果有数值1时用替代值1代替 12345678select [字段,] case 字段 when '数值1' then '替代值1' when '数值2' then '替代值2' .... [else '替代值3'] endfrom 表名; 当查询结果在某个范围时用替代值代替 12345678select [字段,] case when 字段&lt;x then '替代值1' when 字段&lt;y then '替代值1' ... [else '替代值3'] endfrom 表名; 2.decode函数[不推荐]oracle专用函数,要与sign联合使用才能使用范围 123456789select [字段,] decode( 字段, '数值1','替代值1', '数值2','替代值2', .... '替代值3' ) [[as] 别名]from 表名; 3.关联查询​ 可以使用A.*=B.*代表一个表的所有信息； 1.等值连接[不推荐]内部会生成笛卡尔积的表,增加负担,查询结果跟内连接相同,都是现实两表相关联的数据(不存在的不显示) 1select * from A,B where A.x=B.x; 2.内连接 无关联关系 先书写A表数据,依次与B表字段交叉 1select * from A join B; 有关联关系 1select * from 表1 [inner] join 表2 on 表1.x=表2.x; 3.外连接 sql通用语法 1select * from 表1 [left/right] join 表2 on 表1.x=表2.x; oracle专属语法 左连接 1select * from 表1,表2 where 表1.x = 表2.x(+); 右连接 1select * from 表1,表2 where 表1.x(+) = 表2.x; 4.自关联表内字段1与字段2存关联关系,虚拟两张以字段1和字段2为主键的表 1select * from 表名1 别名1 join 表名1 别名2 on 别名1.字段1 = 别名2.字段2; 5.笛卡尔积[无实际意义]1select * from 表1,表2; 4.其他查询1.分组查询oracle中的注意事项:mysql无需注意 只有group by后的列名和被聚合函数修饰的列名,才能出现在select后面; 1select * from 表名 group by 列名; 条件不能使用列名的别名 1select 列名1 别名1 from 表名 group by 列名 having 别名1&gt;200; where只能在表名后,having只能在group by 列名后使用 1select 列名,聚合函数(列名) from 表名 [where] group by 列名 [having]; 2.子查询 通过子查询创建表 1create table 表名 as [(]select * from 表名[)]; 3.分页查询4.其他功能1.序列 创建序列 1create sequence 序列名 [选项1,选项2...]; 选项 作用 默认值 注意事项 increment by n 设置增量为n 1 start with n 设置起始位置n MINVALUE minvalue n 设置最小值n 1 maxvalue n 设置最大值n 最大值 cache n 设置预缓存个数 20 当目前为a时,缓存到a+n cycle/nocycle 是否循环 当设置minvalue和maxvalue时使用,如果设置cycle到极限循环,反之报错 order/noorder 是否按照顺序 获得序列内容 dual:虚表,用于补全查询语法无实际作用 获取下一个内容 在添加记录时使用序列名.nextval替代原先手写的序列值 1select 序列名.nextval from dual 获取当前内容 初始序列不能直接查看当前值,因为当前值还没有创建,必须先获取下一内容然后再查询否则会报错 1select 序列名.currval from dual 删除序列 1drop sequence 序列名; 2.视图创建一个通过查询语句创建出来的同步原表的虚表(实际不存在),并因此修改视图就是在修改原表可用于同步/屏蔽表中关键字段 创建视图 创建读写视图 1create [or replace] view 视图名 as 查询语句 创建只读视图 1create [or replace] view 视图名 as 查询语句 with read only; 删除视图 1drop view 视图名; 修改视图[不推荐] 1update 视图名 set 列名=列值 [条件]; 查看所有视图 1select * from user_views; 3.索引索引就是在表的列上构建一个二叉树,达到大幅度提高查询速率的目的,但是索引会影响增删改的效率 创建单列索引 创建语法 1create index 索引名 on 表名(列名); 触发语法 单行函数,模糊查询都会影响索引的触发.只有列名相同且&quot;x&quot;是该列的值 1select * from where 列名=\"x\"; 创建复合索引 创建语法 1create index 索引名 on 表名(列名1,列名2[,...]) 触发语句 列名1为优先索引,查询条件只有包含列名1=”列名值”才能触发,且x包含在列值中 or时不触发索引 1select * from 表名 where 列名1=\"x\" and 列名2=\"y\"; 删除索引 1drop index 索引名; 查看索引 1select * from user_indexes; 5.数据库管理1.用户要在dba角色权限之下进行操作 创建用户 12create user 用户名 identidfied by 密码 defalult tablespace 表空间名;grant 角色 to 用户名; 删除用户 1drop user 用户名 cascade; 查看用户信息 用户的信息存储在dba_users表中 1select * from dba_users; 锁用户 1alter user scott account unlock; 重置用户密码 1alter user scott indetidied by tiger; 2.sqlplusoracle自带的命令行客户端 启动sqlplus 1sqlplus /nolog 连接数据库 常规输入 1conn 用户名/密码@地址 as sysdba; 防偷窥无密码输入 1conn 用户名/@地址 as sysdba 退出连接 1exit 查看表结构 1desc[ribe] 表名 3.pl/sql1.基础语法 声明方法 1234567891011declare i number(2) :=10; ---直接赋值 ena emp.ename%type; ---引用型变量 emprow emp%rowtype; ---记录型变量begin dbms_output.put_line(i);---输出 select ename into ena from emp where empno = 7369; dbms_output.put_line(ena); select * into emprow from emp where empno = 7369; dbms_output.put_line('姓名:' || emprow.ename || '工作' || emprow.job); end; if语句 1234567891011declare i number(3) := &amp;ii;begin if i&lt;18 then dbms_output.put_line('未成年'); elsif i&lt;40 then dbms_output.put_line('中年人'); else dbms_output.put_line('老年人'); end if;end; loop循环 while循环 12345678declare i number(2) := 1;begin while i&lt;11 loop dbms_output.put_line(i); i:= i+1; end loop;end; exit退出循环 123456789declare i number(2) := 1;begin loop exit when i&gt;10; dbms_output.put_line(i); i:= i+1; end loop;end; for循环 1234567declare begin for i in 1..10 loop dbms_output.put_line(i); end loop;end; 游标:对象 123456789101112declare cursor yb is select * from emp; emprow emp%rowtype; begin open yb; loop fetch yb into emprow; exit when yb%notfound; dbms_output.put_line(emprow.ename); end loop; close yb;end; 1234567891011121314declare cursor c2(eno emp.deptno%type) is select empno from emp where deptno =eno; en emp.empno%type;begin open c2(10); loop fetch c2 into en; exit when c2%notfound; update emp set sal=sal+100 where empno=en; commit; end loop; close c2;end; 2.存储过程类似于无返回值方法 创建存储过程 默认in,被into或:=赋值必须使用out 123456create [or replace] procedure 存储过程名 [out/in] [(参数,参数)]is 声明;begin pl/sql语句;end; 调用存储过程 12345declare 声明;begin 存储过程名(参数);end; 3.存储函数类似有返回值方法 创建存储函数 123456create or replace function 存储函数名[(参数)] return 返回类型is 声明;begin return 返回值;end; 调用存储函数 1select 存储函数(参数) from 表名; 4.触发器就是执行一个规则,在我们做增删改操作的时候,只要满足该规则,自动触发; 创建语句触发器 123456789create [or replace] trigger 触发器名after/beforeinsert/update/deleteon 表名declare 声明;begin 操作;end; 创建行级触发器 raise_application_error函数,可以输出-200001~-209999错误编号,和错误信息 1234567891011create [or replace] trigger 触发器名after/beforeinsert/update/deleteon 表名for each rowdeclarebegin if :old.sal&gt;:new.sal then raise_application_error(-200001,'不能给员工降薪'); end if;end; 触发语句 :old :new Insert null 插入后内容 Update 更新前内容 更新后内容 Delete 删除前内容 null 实现自增主键[案例] 123456789101112---触发器create or replace trigger 触发器名beforeinserton 表名xfor each rowdeclarebegin select 触发器名.nextval into 表名x.主键名 from dual;end;---触发语句insert into 表名x value(主键随机写);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://airbash.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://airbash.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"https://airbash.cn/tags/Oracle/"}]},{"title":"Mysql","slug":"数据库/Mysql","date":"2019-10-31T15:12:38.000Z","updated":"2019-11-06T03:36:22.452Z","comments":true,"path":"2019/10/31/数据库/Mysql/","link":"","permalink":"https://airbash.cn/2019/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/","excerpt":"","text":"1.基础知识1.数据类型 整数 int(n);默认11 zerofill:没有的位数用0补齐（约束） 浮点数 float(20,30) 20:总长度|12小数长度 double decimal 字符串 char(n):不可变长度，执行效率高&lt;255; varchar(n)可变长度，占用空间小&lt;65535;通常用于小字段(小于255); text()可变长度&lt;65535;通常用于文本(大于255); 日期 date:2019-2-20 用符号隔开(建议用-) time:16:32:50 只能用“：” datetime:默认位null;最大值:9999-12-31 timestamp:默认位系统时间;最大值:2019-1-19 2.关联关系 一对一 没有外键，两表的主键和主键建立联系 一对多 正常情况下 多对多 创建一个额外的关联表，用于连接两个表 多对多的意思是两个表中的个别记录都对应了另外一个表的某几个值; 3.约束条件仅在当前字段内生效 1.主键约束 primary key 主键不允许重复，不允许出现空值,可以使用唯一约束和非空约束替代主键约束 2.外键约束 两表的主键和外键建立关系以后，主键所在的表叫做父表，外键所在的表叫做子表，父表的数据不能被先删除，只有删除完所有的子表数据后才能被删除 外键可以重复，允许出现空值 constraint 约束名称 foreign key(外键字段名) references 父表名(被依赖的父表名); 保证表和表之间数据一致性; 父表和子表之间必须使用相同的存储引擎,数据类型相同(字符长度可以不同) 数据表的存储引擎只能为InnoDB 外键列和参照列必须创建索引； 3.唯一约束 unique 不允许出现重复值； 4.非空约束 not null 太多会消耗数据库性能 5.默认约束 default 默认值数据 当没有定义时生效，不包括null; 6.自定义约束 约束 check 自增 auto_increment,可以通过删除自增长字段然后新建自增长字段重置计数器 描述 comment “描述” 2.基本语法1.库操作 创建库 1create database 库名; 查看库 1show databases; 查看创建库语法 1show create database 库名; 切换库 1use 库名; 删除库 1drop database 库名; 2.表操作 创建表 默认:ENGINE=InnoDB DEFAULT CHARSET=utf8 character set = charset 12345create table 表名( 字段名1 类型 约束, 字段名2 类型 约束, ...) [character set 字符集,engine = 存储引擎名]; 查看所有表 1show tables; 查看创建表的语句 1show create table 表名; 查看表结构 1describe 表名; 删除表 1drop table 表名; 删除表的所有记录 1truncate table 表名; 重命名表 1ALTER TABLE 原表名 RENAME TO 新表名; 1rename table 原表名 to 新表名; 3.记录操作 添加记录 标准写法 1insert into 表名 (字段1,字段2...)values(值1,值2...)[,(值1,值2...)...]; 简单写法 1insert into 表名 values (值1,值2...)[,(值1,值2...)]; 删除记录 1delete from 表名 where 字段名 = 值; 更新记录 1update 表名set 新字段名= 新值[,新字段名= 新值] [where 字段名 = 值]; 查询记录 1select * from 表名[where]; 4.字段操作可以同时修改多个字段用(,)表示 修改表信息 1alter table 表名 engine = myisam/innodb charset=utf8/gbk; 增加字段 1alter table 表名 add 字段名 字段类型； 更改字段名或类型 1alter table 表名 change 字段名 新字段名 新字段类型; 更改类型 1alter table 表名 modify 原字段名 新字段类型; 删除字段 1alter table 表名 drop 字段名; 关键字 after(字段1):在字段1后面 first:在第一个字段处 默认：添加在最后一个 3.查询操作1.查询条件 别名： ​ as 字段名 去重： ​ distinct 字段名 横列显示 ​ \\ G 判断比较符号 and 和 &amp;&amp; or 或 || &lt; &gt; = &lt;= &gt;= != &lt;&gt; 数值计算运算符(可用于*和where处) + - * / % a%b=mod(7,2); 连接语法 and/or or若前半段执行成功,后半段不执行 1select * from 表名 where 字段=&quot;值1&quot; or(and) 字段=&quot;值2&quot;; in 1select * from 表名 where 字段名 in (数值1,数值2); between and 1select * from 表名 where 字段名 between X and Y; 包含X\\Y 查询一个字段段满足多种情况时字段要多遍/not 模糊查询like/not % 多个未知字符 _一个未知字符 排序 order by desc 降序 从大到小 asc 升序 从小到大，默认可不写 语法 select * from 表名 order by 字段 desc; 多排序 select * from emp order by 字段1 ,字段2 desc; 分页查询 limit limit a,n; 显示从a+1开始的前n条; 查询最大值使用limit 0,1,id之类的唯一值，需要在将no转换为相对应的其他值;; llimit (a-1)*n,n; 在第a页上显示n条记录； 分组查询 group by(写在排序的后面) 单字段分组:group by 字段 1select [类别字段,]聚合函数(字段) from 表名 group by 类别字段; 多字段分组:groub by 字段1,字段2 1select [类别字段,]聚合函数(字段) from 表名 group by 类别字段; having(写在group by后面) ​ 聚合函数在不分组使用where，分组后用having; 2.查询操作1.普通查询 普通查询 1select 字段1,字段2 from 表名 [查询条件]; 多表查询: 类似无关联关系的内连接,只不过先依次比较库1的字段1 1select 字段1,字段2 from 表1,表2 [查询条件]; 2.子查询 写在where和having后面当作查询条件的值: 查询最大值: 1select * from emp where job = (select job from emp order by sal limit 0,1); 多层子查询 1select * from emp where job = (select job from emp where sal = (select min(sal) from emp)); 创建表: 1create table 表名 as [(]select * from 表名[)]; 虚拟表:必须加别名 1select ename from (select * from emp where deptno=10) newtable; 3.关联(连接)查询​ 可以使用A.*=B.*代表一个表的所有信息； 等值连接 1select * from A,B where A.x=B.x; 内连接 无关联关系 先书写A表数据,依次与B表字段交叉 1select * from A join B; 有关联关系 1select * from A join B on A.x=B.x; 外连接 1select * from A [left/right] join B on A.x=B.x; 自关联(表内字段1与字段2存在一对多的关系) 1select * from 表名X 别名a join 表名X 别名b on 别名a.字段1 = 别名b.字段2; 3.查询函数1.聚合函数计算多条函数中的一个字段的数据,不可以直接输出 函数 作用 注意事项 sum(字段) 总和 avg(字段) 平均值 max(字段) 最大值 min(字段) 最小值 count(字段) 数量 过滤null,建议使用* 2.字符函数 函数 作用 注意事项 upper(str) 转换为大写 lower(str) 转换为小写 char_length(str)获取字符串的长度 select char_length(字段名) from emp; select char_length(&quot;&quot;); instr(str,substr)获取substr在str中出现的位置，从1开始； insert(“字符串”,a,n,”字符串”); trim(str)去两端空白;trim与()之间不能加空格 left(str,index);从左侧开始截取index个字符 right(str,index);从右侧开始截取index个字符 substring(str,index[,length]);substring与()之间不能加空格 repeat(str,count);重复 replace(str,old,new)替换 reverse()反转 3.数字函数 函数 作用 注意事项 round(num,[m]) 对num四舍五入保留m位小数 负数保留到整数位,不写代表0保存到个位 truncate(num,m) 向下取整至m位有效数字 负数保留到整数位,不写代表0保存到个位 floor(num) 将num小数点后的全部删除,负数再减一 rand() 随机小数0-1 flooor(rand()*5); 获取随机整数 结果0.1.2.3.4 4.时间函数 now();系统当前（此处建议书写字段名） curdate();获取当前年月日 curtime();获取当前时分秒 date(now());从完整的内容中提取年月日 time(now());从完整的内容中提取时分秒 extract(year/month/day/hour/minute/second from now());提取单个分量 date_format(时间,格式);日期格式化 格式化 时间 注意事项 %Y/%y 四位年/两位年 %m/%c 两位月/一位月 记忆特殊化 %d 日 %H/%h 24小时/12小时 %i 分 %s 秒 str_to_date(时间字符串,时间字符串格式); select str_to_date(&quot;14.08.2019 08:00:00&quot;,&quot;%d.%m.%Y %H:%i:%s&quot;); 5.其他函数 concat()函数 用于 * ,可以直接输出; select concat(“字符串”，“字符串单位”) from 表名; select concat(&quot;a&quot;,&quot;b&quot;); ifnull(字段，数值) 用于where,不可以直接输出 如果字段为null，输出数值； 4.其他功能1.事务 begin;开始事务 commit;确认事务 rollback;回滚到开始事务处 saverollback 回滚点名称; roolback to 回滚点名称; 注意事项 记录相关的修改可以用到事务 执行同一业务的多条sql语句的工作单位，可以保证多条sql全部执行成功或者全部失败; 在事务没有得到确认之前,操作都是在内存中进行的,只有当commit时才进入到磁盘中去 对表的操作适用 2.视图​ 虚拟表/sql语句复用/隐藏敏感信息 创建视图 1create view 视图名 as (子查询); 创建或修改视图 不存在时创建,存在时修改 1create or replace view 视图名 as (查询语句) 删除视图 1drop view 视图名; 简单视图：增删查改 复杂视图：查 插入数据 insert into 视图名 (字段名1,字段名2) values(数值1，数值2);.注意事项 1234567891011create view v_emp_10 as (select * from emp where deptno = 10);insert into v_emp_10 (empno,ename,deptno) values (10010,&quot;tom&quot;,10);insert into v_emp_10 (empno,ename,deptno) values (10011,&quot;jerry&quot;,20);//数据污染create view v_emp_20 as (select * from emp where deptno = 20) with check option;insert into v_emp_20 (empno,ename,deptno) values (10012,&quot;book&quot;,20);insert into v_emp_20 (empno,ename,deptno) values (10013,&quot;school&quot;,10);//数据添加失败 删除数据 只能删除视图中存在的信息,删除失败时提示删除0条； 创建视图时如果子查询使用了别名则之后进行操作只能使用别名； 3.索引相当于为字段创建索引值,增加查询速度,但是见笑了增加速度 详细信息: 索引是用来快速查询大数据的,与目录的作用相似; 创建索引相当于单独创建了索引表用来帮助查询,但是会消耗空间,提升了查询速度; 索引都是按照字节添加的; 自动创建索引: 创建主键时,会自动创建唯一索引 创建外键时,会自动创建普通索引 索引分类: 默认:从头依次查找 Btree:只用innodb引擎可以使用;从中间查找n/2—1/4n+3/4n二叉树的形式查找. Hash:只有myisam引擎可以使用;查询速度快,一次查询即可出结果,是建立了hash值和字段值对应表 适用情况: 频繁作为查询条件的字段创建索引 排序/统计/分组的字段创建索引 频繁更新的字段不适合创建索引 重复信息过多的不适合创建索引 表记录过少的不适合创建索引 创建索引 单行索引 此处的字段长度是指建立该字段前几个长度的索引，只用于特殊情况(例如价格的89.00只查询整数时) 1create index 索引名 on 表名(字段名[字段长度]); 复合索引 1create index 索引名 on 表名(字段名1[字段长度]),字段名2[字段长度][,...]); 查看索引 1show index from 表名; 删除索引 1drop index 索引名 on 表名; 4.存储引擎 区别 功 能 MYISAM InnoDB Memory Archive 存储限制 256TB 64TB RAM None 支持事务 No Yes No No 支持全文索引 Yes No No No 支持数索引 Yes Yes Yes No 支持哈希索引 No No Yes No 支持数据缓存 No Yes N/A No 支持外键 No Yes No No 注意事项 适用于:增+查 适用于:业务处理 适用小表,类似redis 压缩,只支持增查操作; 相关命令 查看支持的所有存储引擎 1show engines; 选用存储引擎 mysql 5.5以后默认采用innoDB存储引擎 在有外部全文索引插件的情况下建议采用innoDB; 主要用于增加记录和查询记录建议使用myisam,在处理逻辑问题建议使用innoDB; 5.注意事项 若表中已存在记录,这时添加一个有默认值但不是非空字段时,不添加时为默认值,否则是null; 表的名称不区分大小写,存储时默认小写，库区分大小写; 字段名用``包含,可以省略不写; 大小写:show full columns from t_user;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://airbash.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://airbash.cn/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"Mysql","slug":"Mysql","permalink":"https://airbash.cn/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://airbash.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"脚本执行权限","slug":"PowerShell/脚本执行权限","date":"2019-10-31T14:04:26.000Z","updated":"2019-11-06T03:36:22.442Z","comments":true,"path":"2019/10/31/PowerShell/脚本执行权限/","link":"","permalink":"https://airbash.cn/2019/10/31/PowerShell/%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90/","excerpt":"","text":"1.基础知识PowerShell5.1官方文档 策略: 名称 权限 注意事项 Restricted 不允许任何脚本运行 windows默认权限 AllSigned 只能运行经过数字证书签名的脚本 RemoteSigned 权限运行本地的脚本不需要数字签名，但是运行从网络上下载的脚本就必须要有数字签名 windows服务器默认权限 Unrestricted 允许所有的脚本运行 Undefined 所有范围均为Undefined则为Restricted,可用于删除权限 default 设置为默认权限,windows可以用于替代Restricted Bypass windows专用 范围: 范围由大到小进行排列,执行LocalMachine必须要用管理员权限打开powershell 名称 范围 位置 注意事项 MachinePolicy 当前用户 组策略 UserPolicy 所有用户 组策略 Process 当前窗口 $env:PSExecutionPolicyPreference 临时策略 CurrentUser 当前用户 HKEY_CURRENT_USER LocalMachine 所有用户 HKEY_LOCAL_MACHINE 默认设置 2.查看权限 命令 1get-ExecutionPolicy [-参数] 参数 参数 作用 默认不写 获取默认范围 -List 查看全部范围 -Scope 范围 指定某一范围 3.设置权限 命令 1set-ExecutionPolicy [-ExecuionPolity] 权限 [[-Scope] 范围] 参数 书写参数名时参数顺序可颠倒,不书写参数名时顺序不可颠倒 参数 作用 -ExecuionPolity 通常省略不写 -Scope 指定范围,不写更新默认范围","categories":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://airbash.cn/categories/PowerShell/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://airbash.cn/tags/PowerShell/"},{"name":"开源项目","slug":"开源项目","permalink":"https://airbash.cn/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"运维","slug":"运维","permalink":"https://airbash.cn/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"docker","slug":"运维/docker","date":"2017-08-02T13:45:18.000Z","updated":"2019-11-06T03:36:22.459Z","comments":true,"path":"2017/08/02/运维/docker/","link":"","permalink":"https://airbash.cn/2017/08/02/%E8%BF%90%E7%BB%B4/docker/","excerpt":"","text":"1.基础知识 容器之间相互隔离,类似于沙盒机制 1.镜像分类 中间层镜像:镜像之间可以复用的部分 1docker image ls -a//查看所有 虚悬镜像:当镜像打补丁时,再次pull或者build时,新镜像就会替换旧的镜像名,旧镜像名称就会变成&lt;none&gt;; 1docker image prune//删除 2.待补充2.Docker操作1.安装docker官方安装文档,官方文档建议使用yum安装,推荐使用docker社区版本 卸载旧版本:安装过旧版本的执行 12345678sudo yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-engine 安装依赖包 123sudo yum install -y yum-utils \\device-mapper-persistent-data \\lvm2 设置源 /etc/yum.repos.d/下查看 123sudo yum-config-manager \\--add-repo \\https://download.docker.com/linux/centos/docker-ce.repo 安装docker 最新版 1sudo yum install -y docker-ce docker-ce-cli containerd.io 安装特定版本 查看版本 1yum list docker-ce --showduplicates | sort -r 安装特定版本 1sudo yum install docker-ce-版本号 docker-ce-cli-版本号 containerd.io 2.配置docker源 配置docker源[见文档另一种方法和出现冲突处理] 新建/etc/docker/daemon.json,配置腾讯云docker加速源 123&#123; \"registry-mirrors\":[\"https://mirror.ccs.tencentyun.com\"]&#125; 重启服务 1systemctl restart docker-ce 2.卸载Docker 删除docker包 1yum remove docker-ce 删除docker目录 1rm -rf /var/lib/docker 3.Docker命令容器=资源+镜像;镜像:原始包 1.镜像 下载镜像 1docker pull [作者名/]镜像名[:版本] 查看所有镜像 1docker image ls 1docker images 查看镜像层数 1docker history tomcat[:版本] 查看镜像详情 1docker inspcet tomcat 删除镜像/容器 1docker image rm tomcat 1docker rmi tomcat 删除虚悬镜像 1docker image prune 导出镜像 1docker [image] save tomcat &gt; tomcat.tar 导入镜像 1docker [image] load &lt; tomcat.tar 2.容器 创建容器 基础命令 1docker [container] run -参数 参数 run的参数 参数 作用 -i 交互式 -t 伪终端 -d 后台运行 –name 设置容器名 –rm 退出时删除容器 -p 8080:8080 指定端口号 1:主机端口号;2:容器端口号 -v 主机目录:容器目录 数据卷 一般使用 1docker [container] run -itd --name 名字 镜像名 导入导出容器 查看正在运行的容器 显示:容器id、镜像名、COMMAND 、创建时间 、 STATUS 、端口号/协议、容器名 1docker ps 导出容器[可导出运行] 1docker [image] export 容器id/容器名 镜像名.tar 导入容器[可指定名称] 1docker [image] import 镜像名.tar [重命名:建议原名称] 打标记 用之前的镜像创建有个标记不同的镜像 1docker [image] tag tomcat:1 tomcat:标记 进入关闭容器 exit(ctrl+z):关闭容器,ctrl+p+q正常退出 1docker [container] attach 容器名/id 启动容器 1docker [container] start 容器名 关闭容器 1docker [container] stop 容器名 删除容器 1docker [cintainer] rm 容器名 删除停止状态的容器 1docker container prune 容器名/id 进入容器 1docker exec -it 容器名[/容器id bash] 构建镜像 1docker build -t 容器名 /dockefile所在目录 3.部署容器1.mysql 下载mysql镜像 1docker pull mysql:5.7.24 创建容器 -v /usr/local/docker/mysql/conf:/etc/mysql \\ 12345docker run -p 3306:3306 --name mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=mysqlYANGTUO2019 \\-d mysql:5.7.24 4.DockerFile 开头必须是FROM 镜像名 WORKDIR:设置工作目录 RUN + shell脚本 copy:复制 5.Docker-Compose用于批处理run容器 1.安装 下载Compose 或者直接下载上传到/uer/local/bin/docker-compose 1sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 增加可执行权限 1sudo chmod +x /usr/local/bin/docker-compose 2.命令 启动 1docker-compose up 3.yml配置文件docker-compose.yml 官方文档 3级别的可以单独写在1级别上,用于重命名 名称 作用 级别 注意事项 version docker-compose.yml版本号 1 3,兼容之前版本 services 配置多个容器 1 自定义服务名 2 无名称可以自己起 image 指定镜像 3 restart 开机是否启动 3 always:总是启动/no:不启动 container_name 容器名 3 ports 端口映射 3 volumes 数据卷 3 environment 环境变量 3 查看hub文档有相关说明 command 初始化 3 – 4.部署容器1.gitLab 相关资料 这里下载的是gitLab的汉化版,并非官方版,在dockerHub上搜索gitlab-ce-zh搜索选择汉化版本; gitlat中文社区文档 gitlab-docker官方文档 gitlab硬件要求:当前建议8G+7200转机械硬盘或固态硬盘,否则启动和运行都很不理想 docker-compose.yml 12345678910111213141516171819version: '3'services: web: image: 'twang2218/gitlab-ce-zh' restart: unless-stopped hostname: 'www.airbash.cn' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://www.airbash.cn/gitlab' gitlab_rails['time_zone'] = 'Asia/Shanghai' ports: - '8080:80' - '8443:443' - '2222:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab","categories":[{"name":"运维","slug":"运维","permalink":"https://airbash.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://airbash.cn/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"运维","slug":"运维","permalink":"https://airbash.cn/tags/%E8%BF%90%E7%BB%B4/"},{"name":"docker","slug":"docker","permalink":"https://airbash.cn/tags/docker/"}],"author":"ZSP"},{"title":"airbash-主题安装和配置详情","slug":"Hexo/install","date":"2017-07-31T16:00:00.000Z","updated":"2019-11-06T08:03:35.847Z","comments":true,"path":"2017/08/01/Hexo/install/","link":"","permalink":"https://airbash.cn/2017/08/01/Hexo/install/","excerpt":"","text":"一. 主题简介&emsp;&emsp;AirBash 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 二. 安装2.1 安装主题1$ git clone https://github.com/yanxuedesaonian/hexo-theme-airbash.git themes/airbash airbash 主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新12cd themes/airbashgit pull 2.3 依赖安装如下依赖如果已经安装，请看配置介绍。 Json-content生成站点文章静态数据，用于站内搜索。 1npm install hexo-generator-json-content --save 三. 站点配置站点配置文件_config.yml在hexo根目录下。 3.1 启用主题1`theme: airbash` 3.2 网站基本配置以下配置是站点的全局配置，更多配置，请查看 123456title: ZSP's Blogsubtitle: 网站副标题description: 专注 JAVA 开发的技术博客author: ZSPlanguage: 网站使用的语言timezone: 网站时区 3.3 jsonContent配置[可不配置]详细的配置请查看hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 四. 主题配置编辑主题配置文件，themes/airbash/_config.yml,将themes设置为airbash。 4.1 属性下面将介绍几个比较重要的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# hexo-theme-airbash# https://github.com/yanxuedesaonian/hexo-theme-airbash# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: ZSP,ZSP's Blog# Head headline | 头部标题header_title: ZSP's Blog# Head description | 头部描述header_description: 一个专注 JAVA 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //ZSP.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //ZSP.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: ZSP url: //ZSP.com target: true github: title: Github url: //github.com/yanxuedesaonian target: true weibo: title: Weibo url: //weibo.com/ZSPzhaoshuaipeng target: true twitter: title: Twitter url: //twitter.com/huangZSP target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: '#0cc'# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 ZSP 4.2 文章封面图文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。 1cover_picture: images/banner.jpg 4.3 开启背景粒子是否开启背景粒子。 1open_bg_particle: true 4.4 开启主页及头部动画是否开启主页及头部动画。 1open_animation: true 4.5 评论支持畅言、disqus。 1234567# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false 4.6 数据统计支持站长、百度、google三种数据统计，正确填写配置信息即可。 123456# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false 4.7 文章基本配置123456789101112---title: Hello Worlddate: 2017-06-18categories: Firstauthor: ZSPtags: - First - Secondcover_picture: /images/banner.jpg--- ZSP-This is a summary&lt;!-- more --&gt; 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要； cover_picture文章封面图，不填默认显示_config.yml配置的图片。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://airbash.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://airbash.cn/tags/Hexo/"},{"name":"开源项目","slug":"开源项目","permalink":"https://airbash.cn/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"博客","slug":"博客","permalink":"https://airbash.cn/tags/%E5%8D%9A%E5%AE%A2/"}]}]}